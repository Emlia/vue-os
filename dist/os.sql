-- phpMyAdmin SQL Dump
-- version 4.7.4
-- https://www.phpmyadmin.net/
--
-- Host: localhost
-- Generation Time: 2018-05-14 11:26:11
-- 服务器版本： 10.1.28-MariaDB
-- PHP Version: 7.1.11

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `os`
--

-- --------------------------------------------------------

--
-- 表的结构 `answer`
--

CREATE TABLE `answer` (
  `userid` int(11) NOT NULL,
  `orderAnswer` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `chapterAnswer` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `simulation` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `simulationAnswer` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `error` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `errorAnswer` text COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `answer`
--

INSERT INTO `answer` (`userid`, `orderAnswer`, `chapterAnswer`, `simulation`, `simulationAnswer`, `error`, `errorAnswer`) VALUES
(1, '{\"1\":[\"B\"],\"2\":[\"B\"],\"3\":[\"C\"],\"4\":[\"A\"],\"5\":[\"B\"],\"6\":[\"D\"],\"7\":[\"D\"],\"26\":[\"B\"],\"27\":[\"C\"],\"28\":[\"C\"],\"29\":[\"A\"],\"30\":[\"B\"],\"31\":[\"B\"],\"32\":[\"B\"],\"35\":[\"C\"],\"127\":[\"A\"]}', '{}', '[]', '{}', '[\"29\"]', '{}'),
(2, '{\"1\":[\"C\"],\"2\":[\"C\"],\"3\":[\"D\"],\"4\":[\"C\"],\"5\":[\"B\"],\"6\":[\"C\"],\"7\":[\"B\"]}', '{\"1\":[\"D\"]}', '[\"91\",\"11\",\"33\",\"67\",\"111\",\"121\",\"58\",\"51\",\"113\",\"15\",\"2\",\"16\",\"9\",\"88\",\"114\",\"104\",\"112\",\"64\",\"69\",\"31\",\"76\",\"26\",\"80\",\"59\",\"35\",\"57\",\"7\",\"74\",\"73\",\"8\",\"12\",\"101\",\"39\",\"17\",\"72\",\"100\",\"42\",\"99\",\"46\",\"110\",\"85\",\"123\",\"14\",\"71\",\"61\",\"25\",\"79\",\"86\",\"65\",\"93\"]', '{\"7\":[\"C\"],\"73\":[\"B\"],\"91\":[\"C\"]}', '[\"1\",\"2\",\"5\",\"6\",\"7\",\"57\"]', '{\"1\":[\"C\"],\"2\":[\"B\"],\"5\":[\"C\"],\"6\":[\"B\"],\"7\":[\"B\"],\"57\":[\"A\"]}');

-- --------------------------------------------------------

--
-- 表的结构 `chapter`
--

CREATE TABLE `chapter` (
  `id` int(11) NOT NULL,
  `label` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `value` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `chapter`
--

INSERT INTO `chapter` (`id`, `label`, `value`) VALUES
(1, '绪论', '1'),
(2, '进程管理', '2'),
(3, '内存管理和虚拟存储', '3'),
(4, '文件管理', '4'),
(5, '输入/输出(I/O)管理', '5');

-- --------------------------------------------------------

--
-- 表的结构 `configuration`
--

CREATE TABLE `configuration` (
  `id` int(11) NOT NULL,
  `notice` text COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `configuration`
--

INSERT INTO `configuration` (`id`, `notice`) VALUES
(999, '{\"notice\":\"test test ~~\",\"switch\":true}');

-- --------------------------------------------------------

--
-- 表的结构 `question`
--

CREATE TABLE `question` (
  `id` int(11) NOT NULL,
  `type` int(11) NOT NULL,
  `tag` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `chapter` int(11) NOT NULL,
  `answer` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `text` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `src` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `analysis` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `options` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `question`
--

INSERT INTO `question` (`id`, `type`, `tag`, `chapter`, `answer`, `text`, `src`, `analysis`, `options`) VALUES
(1, 1, '[]', 1, '[\"A\"]', '从用户的观点来看,操作系统是', '', 'B,C,D是从功能角度对操作系统的描述', '[\"用户与计算机之间的接口\",\"控制和管理计算机资源的软件\",\"合理地组织计算机工作流程的软件\",\"由若干层次的程序按照一定的结构组成的有机体\"]'),
(2, 1, '[]', 1, '[\"B\"]', '操作系统的功能是进行处理器管理、（  ）管理、设备管理、文件管理及提供用户接口。', '', '题目应该是从资源管理的观点来看的。如果从资源管理的观点来看，操作系统的功能应该包括：\n处理机管理：进程管理应该是属于处理机管理的一部分，不同类型的操作系统将针对不同情况来采取不同的调度策略。如先来先服务、优先级调度、分时轮转等调度策略，来提高系统资源的利用率。\n存储器管理：主要是指针对计算机的主存管理。\n设备管理：主要涉及对系统中的各种输入/输出设备等的管理和控制问题。\n文件管理：又称信息管理或文件系统，在现代计算机操作系统中，将各种信息资源组织成文件存储在计算机的硬盘或者磁带上。文件管理就是对这些信息资源进行存储、检索和保护，以便用户能方便、安全地访问它们。', '[\"进程\",\"存储器\",\"硬件\",\"软件\"]'),
(3, 1, '[]', 1, '[\"D\"]', '操作系统的（  ）管理部分负责对进程进行调度。', '', '进程管理就是控制进程如何使用处理器，所以归类于处理器管理部分。', '[\"主存储器\",\"控制器\",\"运算器\",\"处理器\"]'),
(4, 1, '[]', 1, '[\"C\"]', '在单处理器系统中实现并发技术后，（  ）。', '', '在单处理器系统中，进程与进程是不能并行的，但可以并发。', '[\"各进程在某一时刻并行运行，CPU和I/O设备间并行工作。\",\"各进程在一个时间段内并行运行，CPU和I/O设备间串行工作。\",\"各进程在一个时间段内并行运行，CPU和I/O设备间并行工作。\",\"各进程在某一时刻并行运行，CPU和I/O设备间串行工作。\"]'),
(5, 1, '[]', 1, '[\"D\"]', '订购机票系统处理来自各个终端的服务请求，处理后通过终端回答用户，所以它是一个（  ）', '', '订票系统需根据当前资源余量做出即时响应，属于实时系统。', '[\"分时系统\",\"多道批处理系统\",\"计算机网络\",\"实时信息处理系统\"]'),
(6, 1, '[]', 1, '[\"D\"]', '下列选项中，（  ）不是操作系统关心的主要问题。', '', 'D属于语言处理程序。', '[\"管理计算机裸机\",\"设计提供用户程序与计算机硬件系统的界面\",\"管理计算机系统资源\",\"高级程序设计语言的编译器\"]'),
(7, 1, '[]', 1, '[\"C\"]', '批处理系统的主要缺点是（ \n ）', '', '多道批处理系统的缺点是延长了作业的周转时间，用户不能进行直接干预，缺少交互性，不利于程序的开发与调试。', '[\"CPU利用率\",\"不能并发执行\",\"缺少交互性\",\"以上都不是\"]'),
(8, 1, '[]', 2, '[\"A\"]', '以下关于进程的描述中，（ ）不符合操作系统对进程的理解。', '', '进程是程序关于某个数据集合在处理器上的一次执行过程，可以和别的进程并发执行。', '[\"一个进程只能执行一个程序\",\"进程可以由程序、数据和进程控制块描述\",\"进程是资源分配的基本单位，也是独立运行的基本单位\",\"进程是程序在一个数据集合上运行的过程，它是系统调度的独立单位\"]'),
(9, 1, '[]', 2, '[\"D\"]', '在进程状态转换时，下列转化中不可能发生的是（  ）', '', '阻塞态不能直接转换成执行态，只有就绪态可以变成执行状态。', '[\"就绪状态->执行状态\",\"执行状态->就绪状态\",\"执行状态->阻塞状态\",\"阻塞状态->执行状态\"]'),
(10, 1, '[]', 2, '[\"D\"]', '以下可能导致一个进程从执行状态变成就绪状态的事件是（  ）', '', 'D选项中出现优先级更高的进程，如果系统采用可抢占的调度策略，且高优先级进程已经就绪，则高优先级的进程会抢占处理器，当前进程只能暂停运行，由于只是失去处理器，而不是缺少资源，因此由执行态变为就绪态，选择D。', '[\"一次I/O操作结束\",\"运行进程需要做I/O操作\",\"运行进程结束\",\"出现了比现在进程优先级更高的进程\"]'),
(11, 1, '[]', 2, '[\"C\"]', '进程在（  ）时处于非阻塞状态', '', '当进程等待除处理器以外的其他资源时，都处于阻塞态，只有等待处理器时，进程处于就绪态。', '[\"等待键盘输入数据\",\"等待协助进程的一个信号\",\"等待操作系统分配CPU\",\"等待网络数据进入内存\"]'),
(12, 1, '[]', 2, '[\"A\"]', '下列关于线程和进程的叙述中，正确额是（  ）\nI. 线程包含CPU现场，可以独立执行程序\nII. 每个线程都有自己独立的地址空间\nIII. 线程之间的通信必须使用系统调用函数。\nIV. 线程的切换都需要内核的支持。\nV. 线程是资源分配的单位，进程是调度和分配的单位。VI. 不管系统中是否有线程，进程都是拥有资源的独立单位。', '', '线程都有自己的站空间，可独立执行程序。\n线程没有独立的地址空间，而是依赖从属进程的地址空间。\n当进程有多个用户线程时，线程之间通讯不需要使用系统调用函数，在用户空间就可以进行通讯。\n同一个进程下的多个用户及线程切换，只需要用户空间解决，不需要内核支持。\n进程是系统资源分配和调度的基本单位，线程不能作为独立的资源分配单位。', '[\"I、II、IV\",\"I、VI\",\"II、IV\",\"III、VI\"]'),
(13, 1, '[]', 2, '[\"A\"]', '一个计算机系统中。进程的最大数目，主要受到(  )的限制？', '', '进程创建需要占用系统内存来存放PCB的数据结构。所以一个系统能够创建的进程总数是有限的，进程的最大数目取决于系统内存的大小，系统安装时就已经确定了。若后期内存增加了，系统能够创建的进程总数也应该增加,但一般需要重新启动。而用户数目，外部设备数目和打开的文件数，均与此无关。', '[\"内存的大小\",\"用户数目\",\"打开的文件数\",\"外部设备数量\"]'),
(14, 1, '[]', 2, '[\"A\"]', '时间片轮转调度算法是为了( \n )', '', '时间片轮转调度的目的是为了让所有进程都能够在相对短的时间内得到处理，不让某些终端的进程长时间得不到执行而饿死。', '[\"多个终端能够得到系统的及时响应\",\"使系统变得高效\",\"优先级较高的进程得到及时响应\",\"将需要CPU时间最少的进程最先做完\"]'),
(15, 1, '[]', 2, '[\"B\"]', '设4个作业，从8:00开始，每小时达到1个(即8:00,9:00,10:00,11:00依次到达一个作业)，每个作业的执行时间均为2个小时，系统采用先来先服务和不抢占的调度策略，它们在一台处理器上按照单道运行，则10:00到达的那个作业的响应比为（  ），整个系统的平均周转时间为（  ）小时？', '', '四个作业的周转时间分别为2,3,4,5。\n因此平均周转时间为，(2+3+4+5)÷4=3.5小时。\n作业3的等待时间为2小时，执行时间为2小时，因此周转时间为4小时，响应比为2。', '[\"2,1\",\"2,3.5\",\"3,2.5\",\"3,5\"]'),
(16, 1, '[]', 2, '[\"A\"]', '针对以下的每种情况，选择调度算法。为了照顾紧急作业，用户应采用（  ）；为了能实现多终端人机交互应采用（  ）；为了能使短作业、长作业和交互作业用户都满意，应采用（  ）。\nI. 剥夺式优先级调度算法\nII. 时间片轮转调度算法\nIII. 多级反馈队列调度算法\nIV. 先到先服务调度算法。', '', '需要优化执行，某些作业的情况下应该考虑优先级调度策略。\n对于紧急的作业还需要采用剥夺式调度策略。\n看到多终端和人机交互，则应该想到时间片轮转调度算法。\n能够多种作业类型兼顾的调度算法，只有多级反馈队列调度算法。', '[\"I,II,III\",\"IV,II,III\",\"I,II,IV\",\"I,IV,III\"]'),
(17, 1, '[]', 2, '[\"B\"]', '作业是用户提交的，进程是系统自动生成的，除此之外，两者的区别是(  )', '', '用户提交作业，根据作业内容，系统会生成对应的进程，因此进程所执行的就是作业所包含的代码。\n作业是用户提交的，而进程是由系统生成的，所以作业是以用户任务为单位，而进程则是由系统分配资源和控制运行的基本单位。\n作业和进程是对应的，进程在执行，意味着作业也在执行，因此，并不能说进程是并发执行而作业不是，而且作业不一定是批处理的进程，也不一定是分时的。', '[\"两者执行不同的程序段\",\"前者以用户任务为单位，后者以操作系统控制为单位\",\"前者是批处理的，后者是分时的。\",\"后者可并发执行，前者则不同。\"]'),
(18, 1, '[]', 2, '[\"B\"]', '进程调度算法采用固定时间片轮转调度算法，当时间片过大时,会使轮时间片轮转算法变为（  ）调度算法。', '', '时间片轮转调度算法，是将所有的进程按照到达时间排序，每个进程执行一个时间片的时间，然后切换至下一进程，如果时间过大，则在单个时间片内进程就可以执行结束，因此此时会变成先到先服务。', '[\"高响应比优先\",\"先来先服务\",\"短进程优先\",\"以上都不对\"]'),
(19, 1, '[]', 2, '[\"A\"]', '下列关于剥夺式系统的说法中，正确的是（  ）', '', '时间片轮转调度算法是一种剥夺式调度算法，当时间片用完时，即使当前进程没有执行完，系统也会剥夺当前进程的处理器给下一个进程。', '[\"若系统采用时间片轮转调度进程，则系统采用的是剥夺式调度。\",\"若由于某事件引起调度，则该系统是剥夺式调度\",\"实时系统通常采用剥夺式调度\",\"在剥夺式系统中，进程的周转时间较非剥夺式系统可预见\"]'),
(20, 1, '[]', 2, '[\"C\"]', '以下算法与作业运行时间有关的是（  ）', '', '与运行时间有关的调度算法是短作业优先，多级队列反馈。其他三项与作业的运行时间均无关。\n优先级调度与作业优先级有关。\n时间片轮转与时间片大小于作业的数量有关。\n先来先服务只与到达的次序有关。', '[\"优先级调度\",\"时间片轮转\",\"短作业优先\",\"先来先服务\"]'),
(21, 1, '[]', 2, '[\"C\"]', '下列关于临界区和临界资源叙述中，正确的是(  )\nI. 银行家算法可以用来解决临界区问题\nII. 一个正在访问临界资源的进程，由于申请I/O操作而被阻塞时，不允许其他进程进入临界区和抢占处理器执行\nIII. 公用队列属于临界资源\nIV. 私有据属于临界资源', '', '银行家算法是避免死锁的算法。\n一个正在访问临界资源的进程，由于申请I/O操作时而被阻塞时，不允许其他进程进入临界区，但可以运行其他进程，抢占处理器继续执行。\n公共队列可供多个进程使用，但是一次只可以有一个进程使用。\n适用数据仅供一个进程使用，不存在临界区问题。', '[\"I,II\",\"I,IV\",\"III\",\"IV\"]'),
(22, 1, '[]', 2, '[\"C\"]', '两个旅行社为旅客在航空公司订飞机票，形成互斥资源的是（  ）', '', '互斥资源指被竞争且不能同时使用的资源，机票不能够同时被两个旅客占有，因此机票是互斥资源，旅行社和航空公司都是可以为多个旅客服务，不算互斥资源。', '[\"旅行社\",\"航空公司\",\"飞机票\",\"飞机票和航空公司\"]'),
(23, 1, '[]', 2, '[\"A\"]', '进程a在执行过程中要使用临界资源，但要先获得进程b的计算结果，而此时进程b正在忙于I/O操作，则此时进程a应遵循同步机制的（  ）准则。', '', '进程A需要进程B的结果，而此时进程B没法给A结果，因此A因缺少数据而无法进入自己的临界区，应遵循让权等待原则,放弃处理器给其他进程。', '[\"让权等待\",\"空闲让进\",\"忙则等待\",\"有限等待\"]'),
(24, 1, '[]', 2, '[\"B\"]', '在用信号量机制实现互斥时，互斥信号量的初值为(  )', '', '互斥即同时只允许一个进程访问，初值只能是1表示，同时只允许一个进程进入自己的临界区。\n所有信号量的初值都不能为负数。', '[\"0\",\"1\",\"-1\",\"用户指定\"]'),
(25, 1, '[]', 2, '[\"C\"]', '对于两个并发进程，设置互斥信号量为mutex（初值为1），若mutex=-1,则表示(  )', '', '当有一个进程进入临界区且另一个进程等待进入临界区时，mutex=-1。等mutex小于0时，其绝对值等于等待进入临界区的进程数。', '[\"没有进程进入临界区\",\"有一个进程进入临界区，另一个进程撤销。\",\"有一个进程进入临界区，另一个进程等待进入。\",\"有两个进程进入临界区。\"]'),
(26, 1, '[]', 2, '[\"D\"]', '当一个进程因在互斥信号量mutex上执行V(mutex)操作而导致唤醒另一个进程时，则mutex的值为( )。', '', '由题意可知，原来存在等待进入临界区的进程，故mutex小于等于-1，故在执行V(mutex)操作后，mutex的值小于等于0。', '[\"大于0\",\"小于0\",\"大于等于0\",\"小于等于0\"]'),
(27, 2, '[]', 2, '[\"B\",\"C\"]', '每执行一次P操作，信号量S减一，如果减1后(  )，则该进程继续执行;若(  )，则该进程将被阻塞，并将插入该信号量对应的等待队列中。', '', '', '[\"S大于0\",\"S大于等于0\",\"S小于0\",\"S小于等于0\"]'),
(28, 1, '[]', 2, '[\"B\"]', '若一个系统中共有5个并发进程涉及某个相同的变量A,则变量A的相关临界区是由（  ）个临界区构成的（假设每个进程对于变量A的操作都只有一段代码）。', '', '临界资源是诸进程之间应采取互斥方式访问的，也就是一次只允许一个进程访问的资源，可以为硬件，软件，变量，数据，表格，队列等，并不单指硬件资源。临界区就是每个进程中访问临界资源的那段代码。五个并发进程都涉及了变量A，每一个进程中都有访问变量A的代码，所以每个进程中都有相关临界区，因此是五个临界区构成。', '[\"1\",\"5\",\"与资源数量有关\",\"与进程功能有关\"]'),
(29, 1, '[]', 2, '[\"B\"]', '假设系统中总共有n个进程存在，则阻塞队列中的进程个数最多有（  ）个？', '', '系统中有n个进程，其中至少有一个进程正在执行(处理器至少有一个)，为n-1。但如果死锁，则为n。', '[\"n+1\",\"n\",\"n-1\",\"1\"]'),
(30, 1, '[]', 2, '[\"C\"]', '假设系统中同时存在多个并发进程，那么这些进程之间的关系是(  )', '', '', '[\"进程之间是无关的，系统是封闭的。\",\"进程之间有交互性，并发性,它们既相互依赖，又相互制约。\",\"进程之间可能交互，也可能无关。\",\"以上都不对。\"]'),
(31, 1, '[]', 2, '[\"C\"]', '一个正在访问临界资源的进程，由于申请I/O操作而被阻塞时，（  ）', '', '进程进入临界区必须满足互斥条件，当进程进入临界区但是尚未离开时就被迫进入阻塞是可以的，系统中经常有这样的情形。在此状态下，只要其他进程在运行过程中不寻求进入该进程的临界区，就应该允许其运行。该进程所锁定的临界区是不允许其他进程访问的，其他进程若要访问，必定会在临界区的“锁”上阻塞，期待该进程下次运行时可以离开并将临界区交给它。所以正确答案为C选项。', '[\"可以允许其他进程进入自己的临界资源\",\"不可以允许其他进程进入临界资源和抢占处理器运行\",\"可以允许其他就绪进程抢占处理器，继续执行\",\"不允许其他进程抢占处理器执行\"]'),
(32, 1, '[]', 2, '[\"C\"]', '当出现下列(  )情况时，系统可能会出现死锁。', '', '', '[\"I/O设备利用率很高，CPU利用率很低\",\"一个进程进入死循环\",\"多个进程竞争资源出现了循环等待\",\"多个进程都需要使用共享设备\"]'),
(33, 1, '[]', 2, '[\"C\"]', '为多道程序提供的可共享资源不足时，可能出现死锁，但是，不适当的（  ）也会产生死锁。', '', '产生死锁的两个原因：竞争资源，进程间推进顺序非法。', '[\"进程优先级\",\"资源的线性分配\",\"进程推进顺序\",\"分配队列优先级\"]'),
(34, 1, '[]', 2, '[\"C\"]', '一个进程在获得资源后，只能在使用完资源后由自己释放，这属于死锁必要条件是（  ）', '', '一个进程在获得资源后，只能在使用完资源后由自己释放，也就是说它的资源不能被系统剥夺，答案为C选项。', '[\"互斥条件\",\"请求和保持条件\",\"不剥夺条件\",\"环路等待条件\"]'),
(35, 1, '[]', 2, '[\"D\"]', '资源的有序分配策略可以破坏死锁的（  ）条件', '', '所谓死锁(Deadlock)，是指多个进程在运行 过程中因争夺资源而造成的一种僵局(DeadlyEmbrace)，当进程处于这种僵持状态时，若无 外力作用，它们都将无法再向前推进。\n\n死锁的发生必须具备下列四个必要条件。\n\n(1) 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由 一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源 的进程用毕释放。\n\n(2) 请求和保持条件：指进程已经保持了至少一个资源，但又提出了新的资源请求，而 该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。\n\n(3) 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完 时由自己释放。\n\n(4) 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，…，Pn}中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。\n\n在有序分配资源时，系统将所有资源按类型进行线性排队，并赋予不同的序号。例如， 令输入机的序号为 1，打印机的序号为 2，磁带机为 3，磁盘为 4。所有进程对资源的请求 必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现 环路，因而摒弃了“环路等待”条件。事实上，在采用这种策略时，总有一个进程占据了 较高序号的资源，此后它继续申请的资源必然是空闲的，因而进程可以一直向前推进。', '[\"互斥\",\"请求和保持\",\"不剥夺\",\"循环等待\"]'),
(36, 1, '[]', 2, '[\"B\"]', '某系统中有3个并发进程，都需要同类资源4个，则该系统不会发生死锁的最少资源数目是（  ）个', '', '选临界值，即发生死锁时刻，m个进程，每个进程需要n台机器，（n-1,n-1,n-1……n-1）先给m个进程依次分配 n-1台机器，之后这m台机器都去抢夺最后一台机器，进入死锁状态，则总得机器资源数目为：(n-1)*m+1  上面m=3, n=4代入得 10 ', '[\"9\",\"10\",\"11\",\"12\"]'),
(37, 1, '[]', 2, '[\"D\"]', '死锁预防是保证系统不会进入死锁状态的静态策略，其解决方法是破坏产生死锁的四个必要条件之一，下列方法中破坏了循环等待条件的是（  ）', '', ' 循环等待是死锁的一个条件，一个确保此条件不成立的方法是对所有的资源类型进行完全排序，且要求每个进程按递增顺序来申请资源。', '[\"银行家算法\",\"一次性分配策略\",\"剥夺资源法\",\"资源有序分配策略\"]'),
(38, 1, '[]', 2, '[\"D\"]', '解除死锁通常不采用的方法是（  ）', '', '解除死锁的方法有①剥夺资源：从其他进程中抢占足够的资源给死锁的进程以解除其死锁状态，可以从死锁进程也可以从非死锁进程抢占资源；②撤销进程：撤销一些进程或全部进程以解除死锁状态。', '[\"终止一个死锁进程\",\"终止所有死锁进程\",\"从死锁进程抢夺资源\",\"从非死锁进程抢夺资源\"]'),
(39, 1, '[]', 2, '[\"C\"]', '3个进程，共享4个同类资源，这些资源的分配和释放只能一次一个。已知一个进程，最多需要两个该类资源，则该系统（  ）', '', '不会发生死锁。因为每个进程都分得一个资源时，还有一个资源可以让任意一个进程满足，这样这个进程可以顺利运行完成进而释放它的资源。', '[\"有些进程可能永远得不到该类资源\",\"必然有死锁\",\"进程请求该类资源都能得到\",\"可能有死锁\"]'),
(40, 1, '[]', 2, '[\"D\"]', '死锁与安全状态的关系是（  ）', '', '并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态；死锁状态必定是不安全状态。', '[\"死锁状态有可能是安全状态\",\"安全状态有可能成为死锁状态\",\"不安全状态就是死锁状态\",\"死锁状态一定是不安全状态\"]'),
(41, 1, '[]', 2, '[\"C\"]', '某一系统中测得某处理器的利用率为1%，I/O的利用率为1%，就绪队列中有两个进程，阻塞队列中有31个进程，此时系统出现异常，则表明系统中有进程(  )', '', '死锁是一种互相争夺资源而引起的阻塞现象，它发生在两个或两个以上的进程之间，可能的原因是资源分配不当和进程推进顺序不当。本题描述的现象是系统的运行效率低下，处理机利用率和I/O利用率均很低，而阻塞队列中进程很多，它们既没有等待的I/O(I/O利用率才1%)，也不能唤醒，可能的原因是相互等待对方的资源(如信号、消息、中断或内存资源等)造成了部分死锁。“饥饿”一般发生在个别进程中，可以只涉及单独的进程，不应该影响如此多数量的进程。而抖动时内、外存交互极其频繁，I/O利用率不会很低，因此，可能的结果是死锁。', '[\"空闲\",\"饥饿\",\"死锁\",\"抖动\"]'),
(42, 1, '[]', 2, '[\"B\"]', '在单处理器系统中实现并发技术后（  ）', '', '实现并发技术后，CPU与外设可以并行工作；但由于是单处理器，所以各进程只能在一个时间段内并行运行。', '[\"各进程在某一时刻并行运行，CPU与外部设备并行工作。\",\"各进程在一个时间段内并行运行，CPU与外部设备并行工作。\",\"各进程在一个时间段内并行运行，CPU与外部设备串行工作。\",\"个进程在某一时刻并行运行，CPU与外部设备串行工作。\"]'),
(43, 1, '[]', 2, '[\"D\"]', '支持多道程序设计的操作系统，在运行过程中，不断选择新进程运行，来实现CPU的共享，但其中（  ）不是引起操作系统选择新进程的直接原因？', '', '本题考查的是进程调度的时机。操作系统中将进程的状态分成3种：运行、阻塞、就绪。运行状态的进程占用CPU，就绪状态的进程已经准备好接受调度，但是还没有占有CPU。阻塞进程正在等待某件事情的发生。进程调度只能发生在时间片用完，当前进程等待某事件的发生，或者出错，有更高优先级的进程进入队列(只能出现在优先权调度方法或者抢占式调度中)。', '[\"运行进程的时间片用完\",\"运行进程出错\",\"运行进程要等待某一时间发生\",\"有新进程进入就绪状态\"]'),
(44, 1, '[]', 2, '[\"B\"]', '某单处理器计算机系统中，若同时存在5个进程，则处于执行状态的进程，最多可以有（  ）个。', '', '', '[\"0\",\"1\",\"4\",\"5\"]'),
(45, 1, '[]', 2, '[\"A\"]', '以下关于进程的描述中，正确的是（  ）', '', '', '[\"进程是通过调度得到CPU的\",\"优先级是进程调度的重要依据，一旦确定就不能改变\",\"在单CPU的系统中，任意时刻都至少有一个进程处于就绪状态\",\"进程申请CPU得不到满足时，其状态为阻塞\"]'),
(46, 1, '[]', 2, '[\"A\"]', '一个进程被唤醒意味着（  ）', '', '一个进程被唤醒，意味着进程状态变为就绪', '[\"该进程需要重新竞争CPU\",\"优先级变大\",\"PC B移动到就绪队列之首\",\"进程变为执行状态\"]'),
(47, 1, '[]', 2, '[\"B\"]', '下列情况中必然会引起进程切换的是（  ）', '', '', '[\"一个进程创建后，进入就绪状态\",\"一个进程从执行状态变为就绪状态\",\"一个进程从阻塞状态变为就绪状态\",\"以上都不对\"]'),
(48, 1, '[]', 2, '[\"A\"]', '进程自身决定（  ）', '', '只有从运行状态到阻塞状态的转换是由进程自身决定的。从运行状态到就绪状态的转换是由于进程的时间片用完，“主动”调用程序转向就绪状态。虽然从就绪状态到运行状态的转换同样是由调度程序决定的，但是进程是“被动的”。从阻塞状态到就绪状态的转换是由协作进程决定的。', '[\"从执行状态变为阻塞状态\",\"从执行状态到就绪状态\",\"从就绪状态到执行状态\",\"从阻塞状态到就绪状态\"]'),
(49, 1, '[]', 2, '[\"A\"]', '一次I/O操作的结束，有可能导致（  ）', '', '', '[\"一个进程由阻塞状态变为就绪状态\",\"几个进程由阻塞状态变为就绪状态\",\"一个进程由阻塞状态变为运行状态\",\"几个进程由阻塞状态变为运行状态\"]'),
(50, 1, '[]', 2, '[\"C\"]', '以下（  ）不会引起进程创建。', '', '', '[\"用户登录\",\"作业调度\",\"设备分配\",\"进程请求\"]'),
(51, 1, '[]', 2, '[\"B\"]', '以下关于子进程和父进程的叙述中，正确的是（  ）', '', '在操作系统中，进程是资源分配的基本单位，也是独立运行的基本单位，进程是程序在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位。一个进程可以创建若干个子进程，子进程被创建后，一般与父进程并发执行，以完成特定的任务；父进程创建完子进程后，也可以等待所有子进程结束后再执行；但当撤销一个进程时，操作系统会检查被撤销进程是否有子孙进程，若有子孙进程，还应撤销该进程的子孙进程。当父进程执行完之后被撤销时，子进程也被一同撤销。', '[\"父进程创建子进程，因此父进程运行完之后，子进程才能运行\",\"父进程和子进程可以并发执行\",\"撤销子进程时，应该同时撤销父进程\",\"撤销父进程时，可以不撤销子进程\"]'),
(52, 1, '[]', 2, '[\"D\"]', '并发进程失去封闭性是指（  ）', '', '程序封闭性是指进程执行的结果只取决于进程本身，不受外界影响。也就是说，进程在执行过程中不管是不停顿的执行，还是走走停停，进程的执行速度不会改变它的执行结果。失去封闭性后，不同速度下的执行结果不同。', '[\"多个相对独立的进程，以各自的速度向前推进\",\"并发进程的执行结果与速度无关\",\"并发进程执行时，在不同的时刻发生的错误\",\"并发进程，共享变量，其执行结果与速度无关\"]'),
(53, 1, '[]', 2, '[\"D\"]', '下列对临界资源的论述中正确的是（  ）', '', '多个进程可以共享系统中的资源，一次仅允许一个进程使用的资源叫临界资源。访问临界资源的那段代码称为临界区。', '[\"临界资源是指进程能够同时使用的那些资源\",\"临界区包含进程中实现同步互斥的那段代码\",\"临界区是指存放临界资源的那段存储器区域\",\"临界区是指进程中访问临界资源的那段代码\"]'),
(54, 1, '[]', 2, '[\"B\"]', '在下列死锁的解决方法中，属于死锁防范策略的是（ \n ）', '', '其中，银行家算法为死锁避免算法，死锁检测算法和资源分配图化简法为死锁检测，根据排除法可以得出资源有序分配算法为死锁预防策略。', '[\"银行家算法\",\"资源有序分配算法\",\"死锁检测算法\",\"资源分配图简化法\"]'),
(55, 1, '[]', 2, '[\"C\"]', '一个进程释放了一台打印机后，有可能改变（  ） 的状态。', '', '一个进程释放打印机，另一个等待打印机的进程就可能从阻塞状态转换到就绪状态。', '[\"自身进程\",\"输入输出进程\",\"另一个等待打印机的进程\",\"所有等待打印机的进程\"]'),
(56, 1, '[]', 2, '[\"D\"]', '若系统中有5台绘图仪，有多个进程需要使用2台，规定每个进程一次允许申请一台，则最多允许,（  ）个进程参与竞争，而不会发生死锁。', '', '由上题，r=5，m=2，带入公式，p≤4。因此最多允许4个进程参于竞争。', '[\"5\",\"2\",\"3\",\"4\"]'),
(57, 1, '[]', 3, '[\"C\"]', '支持程序存放在不连续内存中的存储管理方法有（  ）。\n I. 动态分区分配\nII. 固定分区分配\nIII. 分页式分配\nIV. 段页式分配\nV. 分段式分配。', '', '', '[\"I,II\",\"III,IV\",\"III,IV,V\",\"II,iV,V\"]'),
(58, 1, '[]', 3, '[\"C\"]', '某虚拟存储器系统采用页式内存管理，使用LRU页面替换算法，考虑下面的页面访问地址流（每次访问在一个时间单位内完成）：1 8 1 7 8 2 7 2 1 8 3 8 2 1 3 1 7 。假定内存容量为4个页面，开始时是空的，则缺页次数为（  ）', '', '利用LRU置换算法时的置换如下图所示。\n访问页面 1 8 1 7 8 2 7 2 1 8 3 8 2 1 3 1 7 1 3 7 \n物理块1 1 1 1 1 1 1 \n物理块2 8 8 8 8 7 \n物理块3 7 7 3 3 \n物理块4 2 2 2 \n缺页否 √ √ √ √ √ √ \n分别在访问第1个，第2个，第4个，第6个，第11个，第17个页面访问时产生中断，共产生6次中断。', '[\"4\",\"5\",\"6\",\"7\"]'),
(59, 1, '[]', 3, '[\"D\"]', '在动态分区式内存管理中，能使用内存空间中空闲区分布较均匀的算法是（  ）', '', '', '[\"最佳适应算法\",\"最坏适应算法\",\"首次适应算法\",\"循环首次适应算法\"]'),
(60, 1, '[]', 3, '[\"A\"]', '在动态分区式内存管理中，每次分配时，把即能满足要求，又是最小的空闲区分配给进程的算法是（  ）', '', '', '[\"最佳适应算法\",\"最坏适应算法\",\"首次适应算法\",\"循环首次适应算法\"]'),
(61, 1, '[]', 3, '[\"B\"]', '下列关于存储器管理功能的论述中，正确的是（  ）', '', '', '[\"即使是在多道程序设计环境下，用户也能设计用内存物理地址直接访问内存的程序。\",\"内存分配最基本的任务是为了每道程序分配内存，其追求的主要目标是提高存储空间的利用率。\",\"为了提高内存保护的灵活性，内存保护通常由软件实现。\",\"虚拟存储器是在物理上扩充内存容量。\"]'),
(62, 1, '[]', 3, '[\"B\"]', '在下列关于存储器功能的论述中，正确的是（  ）', '', '', '[\"即使在多道程序环境下，用户也可以编制用物理地址直接访问内存的程序\",\"内存分配的基本任务是为每道程序分配内存空间，其追求的目的则是提高内存利用率\",\"为提高内存保护的灵活性，内存保护通常由软件完成\",\"在编译过程中，将程序中的逻辑地址转换为内存空间的物理地址\"]'),
(63, 1, '[]', 3, '[\"C\"]', '在请求调页系统中，若逻辑地址中的页号超过页表控制器寄存器中的页表长度则会引起（  ）', '', '', '[\"输入/输出中断\",\"时钟中断\",\"越界中断\",\"缺页中断\"]'),
(64, 1, '[]', 3, '[\"C\"]', '在段页式分配中，CPU每次从内存中取一次数据，需要访问内存的次数为（  ）', '', '在段页式分配中，取一次数据时先从内存查找段表，再查找相应的页表，最后拼成物理地址后访问内存，共需要3次内存访问。', '[\"1\",\"2\",\"3\",\"4\"]'),
(65, 1, '[]', 3, '[\"B\"]', '在分段式存储管理系统中，为了让两个不同的进程共享同一存储端，下列方法中正确的是（  ）', '', '', '[\"让进程拥有相同的段表\",\"让进程各自的段表项拥有相同的段起始地址和段长度\",\"让进程拥有相同的页表\",\"不同的进程无法实现共享同一存储段\"]'),
(66, 1, '[]', 3, '[\"B\"]', '段页式存储管理，吸取了页式管理和段式管理的长处，其实现原理结合了页式和段式管理的基本思想,即（  ）', '', '段页式存储管理兼有页式管理和段式管理的优点，采用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间。', '[\"用分段方法来分配和管理物理存储空间，用分页方法来管理用户地址空间\",\"用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间\",\"用分段方法来分配和管理主存空间，用分页方法来管理辅存空间\",\"用分段方法来分配和管理辅存空间，用分页方法来管理主存空间\"]'),
(67, 1, '[]', 3, '[\"B\"]', '下列技术中，属于以时间换空间的是（  ）', '', '', '[\"分时技术\",\"虚拟技术\",\"并发技术\",\"缓冲技术\"]'),
(68, 1, '[]', 3, '[\"A\"]', '在请求分页系统中，没有优先考虑最近使用过的页面的置换算法是（  ）', '', '', '[\"最佳置换算法\",\"最近最久未使用算法\",\"先进先出算法\",\"时钟置换算法\"]'),
(69, 1, '[]', 3, '[\"C\"]', '现代操作系统中提高内存利用率的功能是（  。 使每道程序能够在不受干扰的环境下运行的功能是（  ）。\nI. 对换\nII. 内存保护\nIII. 地址映射', '', '', '[\"I,II\",\"I,III\",\"III,II\",\"III,III\"]'),
(70, 1, '[]', 3, '[\"D\"]', '静态重定向是在作业的(  )中进行的,动态重定向是在作业的(  )中进行的。\nI. 编译过程\nII. 装入过程\nIII. 修改过程\nIV. 执行过程。', '', '', '[\"I,III\",\"I,IV\",\"II,III\",\"II,IV\"]'),
(71, 1, '[]', 3, '[\"D\"]', '在请求分页系统中的页表中增加的外存始址的作用是( \n )', '', '', '[\"供分配页面时参考\",\"供置换算法参考\",\"供程序访问时参考\",\"供页面调入/调出时参考\"]'),
(72, 1, '[]', 3, '[\"C\"]', '联想寄存器在计算机系统中用于(  )', '', '', '[\"存储文件信息\",\"与主存交换信息\",\"地址变换\",\"存储通道程序\"]'),
(73, 1, '[]', 3, '[\"B\"]', '程序的装入方式中，目标程序可以不经过任何改动，而装入物理内存单元的是(  )', '', '', '[\"静态重定位\",\"动态重定位\",\"编译或汇编\",\"存储扩充\"]'),
(74, 1, '[]', 3, '[\"D\"]', '分页管理中页表的起始地址存放在(  )中。', '', '', '[\"内存\",\"页表\",\"快表\",\"页表寄存器。\"]'),
(75, 1, '[]', 3, '[\"A\"]', '系统抖动现象发生的原因是(  ) ', '', '', '[\"置换算法选择不当\",\"交换信息量过大\",\"内存容量不足\",\"请求页式管理方案\"]'),
(76, 1, '[]', 3, '[\"A\"]', '在页式存储管理系统中，页表内容如下。若页的大小为4KB。则地址转换机构，将逻辑地址零转换成物理地址为（  ）。\n---------------------------\n页号      |   物理块号\n---------------------------\n0           |     2\n---------------------------\n1           |     0\n---------------------------\n2           |     8\n---------------------------\n3           |    11\n---------------------------', '', '按页表内容可知，逻辑地址0对应块号2，页大小为4KB，故转换成的物理地址为2×4K=8K=8192。', '[\"8192B\",\"1024B\",\"2B\",\"1B\"]'),
(77, 1, '[]', 3, '[\"B\"]', '采用段式存储管理时，一个程序如何分段是在（  ）时候决定的。', '', '在段式存储管理下，用户在编程时需要注明分段，告诉编译器哪些指令属于哪一段，这样编译才能产生正确的虚拟地址。', '[\"分配主存\",\"用户编程\",\"装作\",\"程序执行\"]'),
(78, 1, '[]', 3, '[\"A\"]', '在动态分区式内存管理中，首次适应算法的空闲区（ \n ）', '', '', '[\"按地址递增顺序连在一起\",\"始端指针表指向最大空闲区\",\"按大小递增顺序连在一起\",\"寻找从最大空闲区开始\"]'),
(79, 1, '[]', 3, '[\"C\"]', '考虑使用大小相等分区的固定分区方案，分区大小为2^16B，主存的大小为2^24B，使用一个进程表来包含每一个进程对应的分区，那么进程表中指向这些分区的指针需要的位数为(  )', '', '', '[\"24\",\"16\",\"8\",\"40\"]'),
(80, 1, '[]', 3, '[\"A\"]', '下列关于页表的叙述中错误的是(  )', '', '', '[\"在分页系统中，用户程序能访问页表\",\"在页式管理中，页表的作用是实现从虚页号到物理块号的地址映射\",\"段页式管理中，一个页表属于某个段\",\"在二级页表中，外层页表是指向页表的页表\"]'),
(81, 1, '[]', 3, '[\"B\"]', '在一个操作系统中，对内存采用页式存储管理方法所划分的页面大小（  ）', '', '页式管理是将各进程的虚拟空间划分成若干个长度相等的页，页式管理把内存空间按页的大小划分成片或者页面，然后把页式虚拟地址与内存地址建立一一对应页表，并用相应的硬件地址变换机构，来解决离散地址变换问题。页式管理采用请求调页或预调页技术实现了内外存存储器的统一管理。\n页式管理中很重要的…个概念便是页面大小如何确定。页式管理的特点是：所有单元都是等长的，这样易于系统管理。', '[\"要依据内存大小而定\",\"必须相同\",\"要依据CPU的地址结构而定\",\"要依据内存和外存而定\"]'),
(82, 1, '[]', 3, '[\"D\"]', '下列关于请求分页存储管理说法中，不正确的是（  ）', '', '', '[\"程序空间页的大小与计算机物理块的大小总是一致的\",\"页地址变换机构必须由相应的硬件支持\",\"将用户地址空间分为页号和页内偏移，用户是感觉不到的\",\"在请求调页的系统中，用户程序必须全部装入主存\"]'),
(83, 1, '[]', 3, '[\"C\"]', '下列关于页式存储的说法中，正确的是（  ）\nI. 在页式存储管理中，若关闭TLB，则访问每一条数据都要访问两次主存\nII. 页式存储管理器不会产生内部碎片\nIII. 页式存储管理当中的页面是用户可以感知的\nIV. 页式存储方式，采用静态重定位', '', 'Ⅰ正确：关闭了TLB之后，每当访问一条指令或存取一个操作数时都要先访问页表(内存中)，得到物理地址后，再访问一次内存进行相应操作。Ⅱ错误：记住凡是分区固定的都会产生内部碎片，而无外部碎片。Ⅲ错误：页式存储管理对于用户是透明的。Ⅳ错误：静态重定位是在程序运行之前由装配程序完成的，而页式存储管理方案在运行过程中可能改变程序位置，静态重定位不能满足其要求。', '[\"I,II,IV\",\"I,IV\",\"I\",\"I,III\"]'),
(84, 1, '[]', 3, '[\"A\"]', '下面哪种内存管理方法有利于程序的动态链接(  )', '', '动态链接 是指在作业运行之前，并不把几个 目标程序 段链接起来。要运行时，先将主程序所对应的 目标程序 装入内存并启动运行，当运行过程中又需要调用某段时，才将该段(目标程序)调入内存并进行链接。可见， 动态链接 也要求以段作为管理的单位。', '[\"分段存储管理\",\"分页存储管理\",\"可变式存储管理\",\"固定式存储管理\"]'),
(85, 1, '[]', 3, '[\"C\"]', '设内存的分配情况见。要申请一块40KB的内存空间，若采用最佳适应算法，则所得的分区首址为(  )\n-----------------------------\n地址范围  |     分配情况\n-----------------------------\n0~100KB-1      |     占用\n-----------------------------\n100~180KB-1  |     \n-----------------------------\n180~190KB-1  |    占用\n-----------------------------\n190~280KB-1  |     \n-----------------------------\n280~330KB-1  |     占用\n-----------------------------\n330~390KB-1  |     \n-----------------------------\n390~410KB-1  |     占用\n-----------------------------\n410~512KB-1  |          ', '', '', '[\"100KB\",\"190KB\",\"330KB\",\"410KB\"]'),
(86, 1, '[]', 3, '[\"B\"]', '采用段式存储管理的系统中，若地址用24位表示，其中八位表示段号,则允许每段的最大长度是(  )(默认字长为1B)', '', '2的16次方，地址用24位表示，其中8位是段号，那么真正表示段内地址的只有16位，那么每段最大的段长时2的16次方，也就是64KB', '[\"16MB\",\"64KB\",\"256B\",\"4GB\"]'),
(87, 1, '[]', 3, '[\"A\"]', '在采用请求分页式存储管理的系统中，地址变换过程可能会因下列(  )而产生中断。\nI. 地址越界\nII. 缺页\nIII. 访问权限错误\nIV. 存储控制。', '', '', '[\"I,II\",\"II,III\",\"I,II,III\",\"I,III,IV\"]'),
(88, 1, '[]', 3, '[\"B\"]', '某系统的空闲分区表见表如下所示。采用可变式分区管理策略，现有如下作业序列:96KB、20KB、200KB。若用首次适应算法和最佳适应算法来处理这些作业序列，则(  )该作业序列请求。\n分区号 大小 起始地址 \n1 32KB 100KB \n2 10KB 150KB \n3 5KB 200KB \n4 218KB 220KB \n5 96KB 530KB ', '', '采用首次适应算法时，96KB大小的作业进入4号空闲分区，20KB大小的作业进入1号空闲分区，这时空闲分区如下表所示。\n分区号 大小 起始地址 \n1 12KB 120KB \n2 10KB 150KB \n3 5KB 200KB \n4 122KB 316KB \n5 96KB 530KB \n此时再无空闲分区可以满足200KB大小的作业，所以该作业序列请求无法满足。 采用最佳适应算法时，作业序列分别进入5、1、4号空闲分区，可以满足其请求。分配处理之后的空闲分区表见下表： \n分区号 大小 起始地址 \n1 12KB 120KB \n2 10KB 150KB \n3 5KB 200KB \n4 18KB 420KB ', '[\"首次适应算法能满足最佳适应算法，不能满足\",\"首先得适应算法，不能满足最佳适应算法能满足\",\"都能满足\",\"都不能满足\"]'),
(89, 1, '[]', 3, '[\"B\"]', '设主存容量为1MB，外存容量为400MB，计算机系统的地址寄存器有24位，那么虚拟的最大容量是（  ）（默认字长为1B）', '', '虚拟存储器的最大容量是由计算机的地址结构确定的，其虚拟地址空间=2^24B。', '[\"1MB\",\"16MB\",\"17MB\",\"401MB\"]'),
(90, 1, '[]', 3, '[\"D\"]', '在一分页存储管理系统中，页面大小为4096B，现有一逻辑地址为2F6AH，且第0、1、2页一次存储放在物理块5、10、11中，该逻辑地址对应的物理地址为(  )', '', '4096B=2^12B\n16位寻址一共2^16B\n分页存储.共分的页：2^16/2^12=2^4=16 共分16页.\n第0页的地址范围 0 - FFFH\n第1页的地址范围 1000H - 1FFFH\n第2页得地址范围 2000H - 2FFFH\n.\n第11页 B000H - BFFFH\n第15页 F000H - FFFFH\n2F6AH=10 1111 0110 1010 在2页的范围对应物理块11\n所以物理地址为：\n2F6AH - 2000H + B000H = F6AH + B000H= BF6AH', '[\"2F6AH\",\"5F6AH\",\"5A6AH\",\"BF6AH\"]'),
(91, 1, '[]', 3, '[\"A\"]', '操作系统采用分页存储管理方式要求什么(  )', '', ' 本题考查基本分页存储管理方式的工作原理中，页表的相关概念。在多个进程并发执行时，所有进程的页表大多数驻留在内存中。系统设置一个页表寄存器PTR，里面存放页表在内存的起始地址和页表的长度。当进程为执行时，页表的起始地址和页表长度存放在其PCB中；当进程被调度执行时，才会将页表起始地址和长度装入页表寄存器中。因此本题选择A。', '[\"每一个进程拥有一张页表，且进程的页表驻留在内存中\",\"每个进程拥有一张页表，但只有执行进程的页表驻留在内存中\",\"所有进程共享一张页表，以节约有限的内存空间，但页表必须驻留在内存中\",\"所有进程共享一张页表，只有页表中当前使用的页面必须贮存在内存中。以最大限度的节约有限的内存空间\"]'),
(92, 1, '[]', 3, '[\"D\"]', '以下存储管理方式中会产生内部碎片的是（  ）\nI. 分段虚拟存储管理\nII. 分页虚拟存储管理\nIII. 段页式分页管理\nIV. 固定式分区管理。', '', '只要是固定的分配就会产牛内部碎片，其余的都会产生外部碎片。如果固定和不固定同时存在(例如段页式)，还是看成固定。分段虚拟存储管理：每一段的长度都不一样\n(对应不固定)，所以会产生外部碎片。分页虚拟存储管理：每一页的长度都一样(对应固定)，所以会产生内部碎片。段页式分区管理：既有固定，也有不固定，以固定为主，所以会有内部碎片；固定式分区管理：很明显固定，会产生内部碎片。\n综上分析，Ⅱ、Ⅲ、Ⅳ选项会产生内部碎片。', '[\"I,II,III\",\"III,IV\",\"II\",\"II,III,IV\"]'),
(93, 1, '[]', 4, '[\"B\"]', '文件系统采用二级目录结构，这样可以(  )\nI. 缩短访问文件存储器的时间\nII. 实现文件共享\nIII. 节省主存空间\nIV. 解决不同用户之间的文件名冲突', '', '', '[\"IV\",\"I,IV\",\"III,IV\",\"I,II,IV\"]'),
(94, 1, '[]', 4, '[\"A\"]', '通常对文件系统来说，文件名及其属性可以集中在(  )中，以便查找。', '', '目录里存文件名及其基本信息。', '[\"目录\",\"索引\",\"字典\",\"作业控制块\"]'),
(95, 1, '[]', 4, '[\"C\"]', '文件目录项中不包含的是(  )', '', '', '[\"文件名\",\"文件访问权限说明\",\"文件控制块的物理位置\",\"文件所在的物理位置\"]'),
(96, 1, '[]', 4, '[\"A\"]', '文件系统在创建一个文件时，为它创建一个(  )', '', '', '[\"文件目录项\",\"目录文\",\"逻辑结构\",\"逻辑空间\"]'),
(97, 1, '[]', 4, '[\"D\"]', '在文件系统中，以下不属于文件保护的方法是(  )', '', '本题考查文件保护的方法。在文件系统中，口令、存取控制、用户权限表都是常用的文件保护方法。因此本题选择D。', '[\"口令\",\"存储控制\",\"用户权限表\",\"读写之后使用关闭命令\"]'),
(98, 1, '[]', 4, '[\"A\"]', '操作系统为保证未经文件拥有者授权，任何其他用户不能使用该文件，所提供的解决方法是(  )', '', '', '[\"文件保护\",\"文件保密\",\"文件存储\",\"文件共享\"]'),
(99, 1, '[]', 4, '[\"B\"]', '利用Hash法查找文件时，如果目录中相应的目录项是空，则表示(  )', '', '', '[\"文件名已修改\",\"系统中无指定文件名\",\"创建新的文件\",\"修改已存文件名\"]'),
(100, 1, '[]', 4, '[\"C\"]', '下列(  )不是树形目录的优点', '', '树形目录结构是目前最常用的目录结构，因为它具有如下优点：\n(1)解决了文件的重名问题。\n(2)有利于文件的分类。\n(3)提高了文件的检索速度。\n(4)能进行存取权限的控制。', '[\"解决了文件重名问题\",\"提高了文件的检索速度\",\"根目录到任何文件有多条通路\",\"便于进行存储权限控制\"]'),
(101, 1, '[]', 4, '[\"A\"]', '由字符序列组成，文件内信息不再划分结构，这是指( \n )', '', '', '[\"流式文件\",\"记录式文件\",\"顺序文件\",\"有序文件\"]'),
(102, 1, '[]', 4, '[\"C\"]', '磁盘存储器由(  )组成。\nI. 磁盘\nII. 通道\nIII. 驱动器结构\nIV. 控制器\nV. 缓冲区', '', '', '[\"I,II,V\",\"I,II,IV\",\"I,III,IV\",\"I,IV,V\"]'),
(103, 1, '[]', 4, '[\"B\"]', '磁盘的读写单位是(  )', '', '', '[\"块\",\"扇区\",\"簇\",\"字节\"]'),
(104, 1, '[]', 4, '[\"B\"]', '在文件的逻辑系统中，不属于有结构文件的是（  ）', '', '逻辑结构的文件包括两种：流式文件和记录文件。', '[\"索引文件\",\"分区文件\",\"链接文件\",\"索引顺序文件\"]'),
(105, 1, '[]', 4, '[\"C\"]', '如果文件需要随机访问，且文件大小不固定，则以选择（  ）文件结构。', '', '', '[\"连续\",\"链接\",\"索引\",\"以上都不对\"]'),
(106, 1, '[]', 4, '[\"B\"]', '在下列物理文件中，最不适合对文件进行随机访问的是（  ）', '', '本题主要考查文件的物理结构。连续结构，也称为顺序结构，它是把一个逻辑上连续的记录构成的文件分配到连续的物理块中。这种方式管理简单，存储速度快，空间利用率低，文件记录插入或删除操作不方便。索引结构为每个文件建立一个索引表，其中每一个表项指出文件记录所在的物理块号，表项按逻辑记录编写，顺序或按记录内某一关键字顺序排列，对于大文件，为检索方便，可以建立多级索引，还可以把文件索引表也作为一个文件，称为索引表文件。该方式可以满足文件动态增长的要求且存取方便。链接文件把文件信息存放在非连续的物理块中，每个物理块均设有一个指针指向其后续连续的另一个物理块，从而使得存放同一文件的物理块链接成一个串联队列。所以连续结构是最不利于随机读写和扩展的。', '[\"顺序文件\",\"隐式链接文件\",\"显式链接文件\",\"索引文件\"]'),
(107, 1, '[]', 4, '[\"C\"]', '在某系统中，一个FCB占64B，盘块大小为1KB文件目录中共有3200个FCB，故查找一个文件，平均启动磁盘次数为(  )', '', '', '[\"50\",\"64\",\"100\",\"200\"]'),
(108, 1, '[]', 4, '[\"B\"]', '以下磁盘调度算法中可能出现饥饿现象的是(  )', '', '', '[\"电梯调度\",\"最短寻道时间优先\",\"循环扫描算法\",\"先来先服务\"]'),
(109, 1, '[]', 4, '[\"D\"]', '设磁盘的I/O操作请求队列中的柱面号为55、58、39、18、90、160、150、38、184。磁头的初始位置为100，采用SSTF（最短寻道时间优先算法），则磁头需移动的磁道数为（  ）', '', '', '[\"55\",\"184\",\"200\",\"248\"]'),
(110, 1, '[]', 4, '[\"C\"]', '设磁盘I/O请求队列中柱面号为19，376，205，134,18,56，193，396，29,3,19，40,磁头的起始位置为100，若采用SCAN(电梯调度）算法（磁头的当前是往柱面号小的方向移动)，则磁头移动共需要移动的磁道数为(  )。(该调度算法的磁头移动到镇最内或外侧会改变方向）', '', '采用SCAN算法，磁道的访问顺序是：100、56、40、29、19、18、3、134、193、205、376、396。移动磁道次数分别为：44、16、11、10、1、15、131、59、12、171、20。磁头移动总数为490。因此本题选择C。', '[\"205\",\"480\",\"490\",\"512\"]'),
(111, 1, '[]', 4, '[\"C\"]', '若用8个字(字长为32位)组成的位示图管理内存，假定用户归还一个块号为100的内存块时，它对应的位置图的位置为(  )(统一由0开始编号)', '', '本题的位示图中n=32，b=100，i=(b-1)/ n=3，j=(b-1)mod n+1=4。因此本题选择B。', '[\"字号为3，位号为5\",\"字号为4，位号为4\",\"字号为3，位号为4\",\"字号为4，位号为5\"]'),
(112, 1, '[]', 5, '[\"C\"]', '在I/O设备控制方式的发展过程中，最主要的推动力是(  )', '', '', '[\"提高资源利用率\",\"提高系统吞吐量\",\"减少CPU对I/O控制的干扰\",\"缓解CPU速度与I/O速度不匹配的矛盾\"]'),
(113, 1, '[]', 5, '[\"C\"]', 'CPU输出数据的速度远远高于打印机的打印速度，为解决这一矛盾可采用(  )', '', '', '[\"并行技术\",\"通道技术\",\"缓冲技术\",\"虚存技术\"]'),
(114, 1, '[]', 5, '[\"D\"]', '设备的打开关闭读写等操作是由(  )完成的', '', '', '[\"用户程序\",\"编译程序\",\"设备分配程序\",\"设备驱动程序\"]'),
(115, 1, '[]', 5, '[\"A\"]', 'DMA控制方式是在(  )之间建立一条直接数据通路。', '', '', '[\"I/O设备和主存\",\"两个I/O设备\",\"I/O设备和CPU\",\"CPU和主存\"]'),
(116, 1, '[]', 5, '[\"C\"]', '在一般大型计算机系统中，主机对外部设备的控制可以通过通道控制器和设备三个层次来实现，以下叙述中正确的是(  )', '', '', '[\"设备控制器和通道可以分别控制设备\",\"设备控制器，通道和设备可以并行工作\",\"通道控制设备控制器，设备控制器，控制设备工作\",\"以上都不对\"]'),
(117, 1, '[]', 5, '[\"A\"]', '大多数低速设备都属于（  ）设备。', '', '', '[\"独享\",\"共享\",\"虚拟\",\"SPOOLing\"]'),
(118, 1, '[]', 5, '[\"B\"]', '在操作系统中，用户使用I/O时，通常采用的是(  )', '', '', '[\"物理设备名\",\"逻辑设备名\",\"虚拟设备名\",\"设备牌号\"]'),
(119, 1, '[]', 5, '[\"C\"]', '下列算法中，设备分配常用的一种算法是(  )', '', '', '[\"短作业优先\",\"最佳适应\",\"先来先服务\",\"首次适应\"]'),
(120, 1, '[]', 5, '[\"A\"]', '将系统中的每一台设备按某种原则进行统一编号，这些编号作为区分硬件和识别设备的代号，该编号称为设备的(  )', '', '', '[\"绝对号\",\"相对号\",\"类型号\",\"符号名\"]'),
(121, 1, '[]', 5, '[\"D\"]', 'SPOOLing技术主要的目的是(  )', '', '', '[\"提高CPU和设备交换信息的速度\",\"提高主辅存接口\",\"减轻用户的编程负担\",\"提高独占设备的利用率\"]'),
(122, 1, '[]', 5, '[\"C\"]', '下列存储介质中即可随机访问又和顺序访问的是（ \n ）。\nI. 光盘\nII. SD卡\nIII. U盘\nIV. 磁盘。', '', '', '[\"II,III,IV\",\"I,III,IV\",\"I,II,III,IV\",\"IV\"]'),
(123, 1, '[]', 5, '[\"C\"]', '大多数设备控制器是由三部分组成的，其中用于实现对设备的控制的是（  ）', '', '设备控制器包括：设备控制器与处理器的接口，有三种总线构成；I/O逻辑，通过译码器找到所控制的设备；设备控制器与设备的接口，对设备进行控制。', '[\"设备控制器与处理器的接口\",\"设备控制器与设备的接口\",\"I/O逻辑\",\"以上都不对\"]'),
(124, 1, '[]', 5, '[\"D\"]', '在设备管理中，设备映射表(DMT)的作用是(  )', '', '', '[\"管理物理设\",\"管理逻辑设备\",\"实现输入/输出\",\"建立逻辑设备与物理设备的对应关系\"]'),
(125, 1, '[]', 5, '[\"D\"]', 'SPOOLing系统的输入井和输出井表示（  ）', '', '', '[\"磁盘上的两个存储器\",\"内存中的两个缓冲区\",\"输入设备和输出设备\",\"存放用户的输入数据和输出数据的外存空间\"]'),
(126, 1, '[]', 5, '[\"A\"]', '缓存技术的缓冲池在（  ）中。', '', '', '[\"内存\",\"外存\",\"ROM\",\"寄存器\"]');

-- --------------------------------------------------------

--
-- 表的结构 `tag`
--

CREATE TABLE `tag` (
  `id` int(11) NOT NULL,
  `label` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `value` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `tag`
--

INSERT INTO `tag` (`id`, `label`, `value`) VALUES
(4, '死锁', 'Deadlock'),
(5, '线程', 'thread'),
(6, '状态', 'state');

-- --------------------------------------------------------

--
-- 表的结构 `type`
--

CREATE TABLE `type` (
  `id` int(11) NOT NULL,
  `label` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `value` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `type`
--

INSERT INTO `type` (`id`, `label`, `value`) VALUES
(1, '单选', 'radio'),
(2, '多选', 'checkbox');

-- --------------------------------------------------------

--
-- 表的结构 `user`
--

CREATE TABLE `user` (
  `id` int(11) NOT NULL,
  `username` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `password` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `appkey` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `user`
--

INSERT INTO `user` (`id`, `username`, `password`, `appkey`) VALUES
(1, 'admin', '21232f297a57a5a743894a0e4a801fc3', 'c4ec3c7f0481b304e27849f83f14da26'),
(2, 'emlia', '80f8f403131321e767c5400d8f4566eb', 'e4630eed1770cd55d3aea22296873249'),
(3, 'emlia11', '9d9439dde114c37991eacd2036a1fadd', '530cd7f787ec5ad4a16d0e43f3c611bd'),
(4, 'emlia111', 'fa7a42779e8be95e2c8b23e2043c9423', 'f8b1a135c61b9bf08057ee4c3ae273f4'),
(5, 'emlia112', '60ecf5d6cfcd4d67f5bd4ab920d94d60', 'ef79560d08c1d1a40dfa3dbe3997d902');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `answer`
--
ALTER TABLE `answer`
  ADD PRIMARY KEY (`userid`);

--
-- Indexes for table `chapter`
--
ALTER TABLE `chapter`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `configuration`
--
ALTER TABLE `configuration`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `question`
--
ALTER TABLE `question`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `tag`
--
ALTER TABLE `tag`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `type`
--
ALTER TABLE `type`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `user`
--
ALTER TABLE `user`
  ADD PRIMARY KEY (`id`);

--
-- 在导出的表使用AUTO_INCREMENT
--

--
-- 使用表AUTO_INCREMENT `chapter`
--
ALTER TABLE `chapter`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=6;

--
-- 使用表AUTO_INCREMENT `configuration`
--
ALTER TABLE `configuration`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=1000;

--
-- 使用表AUTO_INCREMENT `question`
--
ALTER TABLE `question`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=127;

--
-- 使用表AUTO_INCREMENT `tag`
--
ALTER TABLE `tag`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=7;

--
-- 使用表AUTO_INCREMENT `type`
--
ALTER TABLE `type`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=3;

--
-- 使用表AUTO_INCREMENT `user`
--
ALTER TABLE `user`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=6;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;