-- phpMyAdmin SQL Dump
-- version 4.7.4
-- https://www.phpmyadmin.net/
--
-- Host: localhost
-- Generation Time: 2018-05-02 04:38:02
-- 服务器版本： 10.1.28-MariaDB
-- PHP Version: 7.1.11

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `os`
--

-- --------------------------------------------------------

--
-- 表的结构 `answer`
--

CREATE TABLE `answer` (
  `userid` int(11) NOT NULL,
  `orderAnswer` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `simulationAnswer` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `chapterAnswer` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `error` text COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `answer`
--

INSERT INTO `answer` (`userid`, `orderAnswer`, `simulationAnswer`, `chapterAnswer`, `error`) VALUES
(1, '{}', '{}', '{}', '[]');

-- --------------------------------------------------------

--
-- 表的结构 `chapter`
--

CREATE TABLE `chapter` (
  `id` int(11) NOT NULL,
  `label` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `value` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `chapter`
--

INSERT INTO `chapter` (`id`, `label`, `value`) VALUES
(1, '绪论', '1'),
(2, '进程管理', '2'),
(3, '内存管理和虚拟存储', '3'),
(4, '文件管理', '4'),
(5, '输入/输出(I/O)管理', '5');

-- --------------------------------------------------------

--
-- 表的结构 `configuration`
--

CREATE TABLE `configuration` (
  `id` int(11) NOT NULL,
  `notice` text COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `configuration`
--

INSERT INTO `configuration` (`id`, `notice`) VALUES
(999, '{\"notice\":\"哈哈~eesx\",\"switch\":true}');

-- --------------------------------------------------------

--
-- 表的结构 `question`
--

CREATE TABLE `question` (
  `id` int(11) NOT NULL,
  `type` int(11) NOT NULL,
  `tag` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `chapter` int(11) NOT NULL,
  `answer` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `text` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `src` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `analysis` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `options` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `question`
--

INSERT INTO `question` (`id`, `type`, `tag`, `chapter`, `answer`, `text`, `src`, `analysis`, `options`) VALUES
(1, 1, '[]', 1, '[\"A\"]', '从用户的观点来看,操作系统是', '', 'B,C,D是从功能角度对操作系统的描述', '[\"用户与计算机之间的接口\",\"控制和管理计算机资源的软件\",\"合理地组织计算机工作流程的软件\",\"由若干层次的程序按照一定的结构组成的有机体\"]'),
(2, 1, '[]', 1, '[\"B\"]', '操作系统的功能是进行处理器管理、（  ）管理、设备管理、文件管理及提供用户接口。', '', '题目应该是从资源管理的观点来看的。如果从资源管理的观点来看，操作系统的功能应该包括：\n处理机管理：进程管理应该是属于处理机管理的一部分，不同类型的操作系统将针对不同情况来采取不同的调度策略。如先来先服务、优先级调度、分时轮转等调度策略，来提高系统资源的利用率。\n存储器管理：主要是指针对计算机的主存管理。\n设备管理：主要涉及对系统中的各种输入/输出设备等的管理和控制问题。\n文件管理：又称信息管理或文件系统，在现代计算机操作系统中，将各种信息资源组织成文件存储在计算机的硬盘或者磁带上。文件管理就是对这些信息资源进行存储、检索和保护，以便用户能方便、安全地访问它们。', '[\"进程\",\"存储器\",\"硬件\",\"软件\"]'),
(3, 1, '[]', 1, '[\"D\"]', '操作系统的（  ）管理部分负责对进程进行调度。', '', '进程管理就是控制进程如何使用处理器，所以归类于处理器管理部分。', '[\"主存储器\",\"控制器\",\"运算器\",\"处理器\"]'),
(4, 1, '[]', 1, '[\"C\"]', '在单处理器系统中实现并发技术后，（  ）。', '', '在单处理器系统中，进程与进程是不能并行的，但可以并发。', '[\"各进程在某一时刻并行运行，CPU和I/O设备间并行工作。\",\"各进程在一个时间段内并行运行，CPU和I/O设备间串行工作。\",\"各进程在一个时间段内并行运行，CPU和I/O设备间并行工作。\",\"各进程在某一时刻并行运行，CPU和I/O设备间串行工作。\"]'),
(5, 1, '[]', 1, '[\"D\"]', '订购机票系统处理来自各个终端的服务请求，处理后通过终端回答用户，所以它是一个（  ）', '', '订票系统需根据当前资源余量做出即时响应，属于实时系统。', '[\"分时系统\",\"多道批处理系统\",\"计算机网络\",\"实时信息处理系统\"]'),
(6, 1, '[]', 1, '[\"D\"]', '下列选项中，（  ）不是操作系统关心的主要问题。', '', '', '[\"管理计算机裸机\",\"设计提供用户程序与计算机硬件系统的界面\",\"管理计算机系统资源\",\"高级程序设计语言的编译器\"]'),
(7, 1, '[]', 1, '[\"C\"]', '批处理系统的主要缺点是（ \n ）', '', '多道批处理系统的缺点是延长了作业的周转时间，用户不能进行直接干预，缺少交互性，不利于程序的开发与调试。', '[\"CPU利用率\",\"不能并发执行\",\"缺少交互性\",\"以上都不是\"]'),
(8, 1, '[]', 2, '[\"A\"]', '以下关于进程的描述中，（ ）不符合操作系统对进程的理解。', '', '进程是程序关于某个数据集合在处理器上的一次执行过程，可以和别的进程并发执行。', '[\"一个进程只能执行一个程序\",\"进程可以由程序、数据和进程控制块描述\",\"进程是资源分配的基本单位，也是独立运行的基本单位\",\"进程是程序在一个数据集合上运行的过程，它是系统调度的独立单位\"]'),
(9, 1, '[]', 2, '[\"D\"]', '在进程状态转换时，下列转化中不可能发生的是（  ）', '', '阻塞态不能直接转换成执行态，只有就绪态可以变成执行状态。', '[\"就绪状态->执行状态\",\"执行状态->就绪状态\",\"执行状态->阻塞状态\",\"阻塞状态->执行状态\"]'),
(10, 1, '[]', 2, '[\"D\"]', '以下可能导致一个进程从执行状态变成就绪状态的事件是（  ）', '', '', '[\"一次I/O操作结束\",\"运行进程需要做I/O操作\",\"运行进程结束\",\"出现了比现在进程优先级更高的进程\"]'),
(11, 1, '[]', 2, '[\"C\"]', '进程在（  ）时处于非阻塞状态', '', '', '[\"等待键盘输入数据\",\"等待协助进程的一个信号\",\"等待操作系统分配CPU\",\"等待网络数据进入内存\"]'),
(12, 1, '[]', 2, '[\"A\"]', '下列关于线程和进程的叙述中，正确额是（  ）\nI. 线程包含CPU现场，可以独立执行程序\nII. 每个线程都有自己独立的地址空间\nIII. 线程之间的通信必须使用系统调用函数。\nIV. 线程的切换都需要内核的支持。\nV. 线程是资源分配的单位，进程是调度和分配的单位。VI. 不管系统中是否有线程，进程都是拥有资源的独立单位。', '', '', '[\"I、II、IV\",\"I、VI\",\"II、IV\",\"III、VI\"]'),
(13, 1, '[]', 2, '[\"A\"]', '一个计算机系统中。进程的最大数目，主要受到(  )的限制？', '', '', '[\"内存的大小\",\"用户数目\",\"打开的文件数\",\"外部设备数量\"]'),
(14, 1, '[]', 2, '[\"A\"]', '时间片轮转调度算法是为了( \n )', '', '', '[\"多个终端能够得到系统的及时响应\",\"使系统变得高效\",\"优先级较高的进程得到及时响应\",\"将需要CPU时间最少的进程最先做完\"]'),
(15, 1, '[]', 2, '[\"B\"]', '设4个作业，从8:00开始，每小时达到1个(即8:00,9:00,10:00,11:00依次到达一个作业)，每个作业的执行时间均为2个小时，系统采用先来先服务和不抢占的调度策略，它们在一台处理器上按照单道运行，则10:00到达的那个作业的响应比为（  ），整个系统的平均周转时间为（  ）小时？', '', '', '[\"2,1\",\"2,3.5\",\"3,2.5\",\"3,5\"]'),
(16, 1, '[]', 2, '[\"A\"]', '针对以下的每种情况，选择调度算法。为了照顾紧急作业，用户应采用（  ）；为了能实现多终端人机交互应采用（  ）；为了能使短作业、长作业和交互作业用户都满意，应采用（  ）。\nI. 剥夺式优先级调度算法\nII. 时间片轮转调度算法\nIII. 多级反馈队列调度算法\nIV. 先到先服务调度算法。', '', '', '[\"I,II,III\",\"IV,II,III\",\"I,II,IV\",\"I,IV,III\"]'),
(17, 1, '[]', 2, '[\"B\"]', '作业是用户提交的，进程是系统自动生成的，除此之外，两者的区别是(  )', '', '', '[\"两者执行不同的程序段\",\"前者以用户任务为单位，后者以操作系统控制为单位\",\"前者是批处理的，后者是分时的。\",\"后者可并发执行，前者则不同。\"]'),
(18, 1, '[]', 2, '[\"B\"]', '进程调度算法采用固定时间片轮转调度算法，当时间片过大时,会使轮时间片轮转算法变为（  ）调度算法。', '', '', '[\"高响应比优先\",\"先来先服务\",\"短进程优先\",\"以上都不对\"]'),
(19, 1, '[]', 2, '[\"A\"]', '下列关于剥夺式系统的说法中，正确的是（  ）', '', '', '[\"若系统采用时间片轮转调度进程，则系统采用的是剥夺式调度。\",\"若由于某事件引起调度，则该系统是剥夺式调度\",\"实时系统通常采用剥夺式调度\",\"在剥夺式系统中，进程的周转时间较非剥夺式系统可预见\"]'),
(20, 1, '[]', 2, '[\"C\"]', '以下算法与作业运行时间有关的是（  ）', '', '', '[\"优先级调度\",\"时间片轮转\",\"短作业优先\",\"先来先服务\"]'),
(21, 1, '[]', 2, '[\"C\"]', '下列关于临界区和临界资源叙述中，正确的是(  )\nI. 银行家算法可以用来解决临界区问题\nII. 一个正在访问临界资源的进程，由于申请I/O操作而被阻塞时，不允许其他进程进入临界区和抢占处理器执行\nIII. 公用队列属于临界资源\nIV. 私有据属于临界资源', '', '', '[\"I,II\",\"I,IV\",\"III\",\"IV\"]'),
(22, 1, '[]', 2, '[\"C\"]', '两个旅行社为旅客在航空公司订飞机票，形成互斥资源的是（  ）', '', '', '[\"旅行社\",\"航空公司\",\"飞机票\",\"飞机票和航空公司\"]'),
(23, 1, '[]', 2, '[\"A\"]', '进程a在执行过程中要使用临界资源，但要先获得进程b的计算结果，而此时进程b正在忙于I/O操作，则此时进程a应遵循同步机制的（  ）准则。', '', '', '[\"让权等待\",\"空闲让进\",\"忙则等待\",\"有限等待\"]'),
(24, 1, '[]', 2, '[\"B\"]', '在用信号量机制实现互斥时，互斥信号量的初值为(  )', '', '', '[\"0\",\"1\",\"-1\",\"用户指定\"]'),
(25, 1, '[]', 2, '[\"C\"]', '对于两个并发进程，设置互斥信号量为mutex（初值为1），若mutex=-1,则表示(  )', '', '', '[\"没有进程进入临界区\",\"有一个进程进入临界区，另一个进程撤销。\",\"有一个进程进入临界区，另一个进程等待进入。\",\"有两个进程进入临界区。\"]'),
(26, 1, '[]', 2, '[\"D\"]', '当一个进程因在互斥信号量上执行V操作而导致唤醒另一个进程时，则互斥信号量现在的取值为(  )', '', '', '[\"大于0\",\"小于0\",\"大于等于0\",\"小于等于0\"]'),
(27, 2, '[]', 2, '[\"B\",\"C\"]', '每执行一次P操作，信号量S减一，如果减1后(  )，则该进程继续执行;若(  )，则该进程将被阻塞，并将插入该信号量对应的等待队列中。', '', '', '[\"S大于0\",\"S大于等于0\",\"S小于0\",\"S小于等于0\"]'),
(28, 1, '[]', 2, '[\"B\"]', '若一个系统中共有5个并发进程涉及某个相同的变量A,则变量A的相关临界区是由（  ）个临界区构成的（假设每个进程对于变量A的操作都只有一段代码）。', '', '', '[\"1\",\"5\",\"与资源数量有关\",\"与进程功能有关\"]'),
(29, 1, '[]', 2, '[\"B\"]', '假设系统中总共有n个进程存在，则阻塞队列中的进程个数最多有（  ）个？', '', '', '[\"n+1\",\"n\",\"n-1\",\"1\"]'),
(30, 1, '[]', 2, '[\"C\"]', '假设系统中同时存在多个并发进程，那么这些进程之间的关系是(  )', '', '', '[\"进程之间是无关的，系统是封闭的。\",\"进程之间有交互性，并发性,它们既相互依赖，又相互制约。\",\"进程之间可能交互，也可能无关。\",\"以上都不对。\"]'),
(31, 1, '[]', 2, '[\"C\"]', '一个正在访问临界资源的进程，由于申请I/O操作而被阻塞时，（  ）', '', '', '[\"可以允许其他进程进入自己的临界资源\",\"不可以允许其他进程进入临界资源和抢占处理器运行\",\"可以允许其他就绪进程抢占处理器，继续执行\",\"不允许其他进程抢占处理器执行\"]'),
(32, 1, '[]', 2, '[\"C\"]', '当出现下列(  )情况时，系统可能会出现死锁。', '', '', '[\"I/O设备利用率很高，CPU利用率很低\",\"一个进程进入死循环\",\"多个进程竞争资源出现了循环等待\",\"多个进程都需要使用共享设备\"]'),
(33, 1, '[]', 2, '[\"C\"]', '为多道程序提供的可共享资源不足时，可能出现死锁，但是，不适当的（  ）也会产生死锁。', '', '', '[\"进程优先级\",\"资源的线性分配\",\"进程推进顺序\",\"分配队列优先级\"]'),
(34, 1, '[]', 2, '[\"C\"]', '一个进程在获得资源后，只能在使用完资源后由自己释放，这属于死锁必要条件是（  ）', '', '', '[\"互斥条件\",\"请求和保持条件\",\"不剥夺条件\",\"环路等待条件\"]'),
(35, 1, '[]', 2, '[\"D\"]', '资源的有序分配策略可以破坏死锁的（  ）条件', '', '', '[\"互斥\",\"请求和保持\",\"不剥夺\",\"循环等待\"]'),
(36, 1, '[]', 2, '[\"B\"]', '某系统中有3个并发进程，都需要同类资源4个，则该系统不会发生死锁的最少资源数目是（  ）个', '', '', '[\"9\",\"10\",\"11\",\"12\"]'),
(37, 1, '[]', 2, '[\"D\"]', '死锁预防是保证系统不会进入死锁状态的静态策略，其解决方法是破坏产生死锁的四个必要条件之一，下列方法中破坏了循环等待条件的是（  ）', '', '', '[\"银行家算法\",\"一次性分配策略\",\"剥夺资源法\",\"资源有序分配策略\"]'),
(38, 1, '[]', 2, '[\"D\"]', '解除死锁通常不采用的方法是（  ）', '', '', '[\"终止一个死锁进程\",\"终止所有死锁进程\",\"从死锁进程抢夺资源\",\"从非死锁进程抢夺资源\"]'),
(39, 1, '[]', 2, '[\"C\"]', '3个进程，共享4个同类资源，这些资源的分配和释放只能一次一个。已知一个进程，最多需要两个该类资源，则该系统（  ）', '', '', '[\"有些进程可能永远得不到该类资源\",\"必然有死锁\",\"进程请求该类资源都能得到\",\"可能有死锁\"]'),
(40, 1, '[]', 2, '[\"D\"]', '死锁与安全状态的关系是（  ）', '', '', '[\"死锁状态有可能是安全状态\",\"安全状态有可能成为死锁状态\",\"不安全状态就是死锁状态\",\"死锁状态一定是不安全状态\"]'),
(41, 1, '[]', 2, '[\"C\"]', '某一系统中测得某处理器的利用率为1%，I/O的利用率为1%，就绪队列中有两个进程，阻塞队列中有31个进程，此时系统出现异常，则表明系统中有进程(  )', '', '', '[\"空闲\",\"饥饿\",\"死锁\",\"抖动\"]'),
(42, 1, '[]', 2, '[\"B\"]', '在单处理器系统中实现并发技术后（  ）', '', '', '[\"各进程在某一时刻并行运行，CPU与外部设备并行工作。\",\"各进程在一个时间段内并行运行，CPU与外部设备并行工作。\",\"各进程在一个时间段内并行运行，CPU与外部设备串行工作。\",\"个进程在某一时刻并行运行，CPU与外部设备串行工作。\"]'),
(43, 1, '[]', 2, '[\"D\"]', '支持多道程序设计的操作系统，在运行过程中，不断选择新进程运行，来实现CPU的共享，但其中（  ）不是引起操作系统选择新进程的直接原因？', '', '', '[\"运行进程的时间片用完\",\"运行进程出错\",\"运行进程要等待某一时间发生\",\"有新进程进入就绪状态\"]'),
(44, 1, '[]', 2, '[\"B\"]', '某单处理器计算机系统中，若同时存在5个进程，则处于执行状态的进程，最多可以有（  ）个。', '', '', '[\"0\",\"1\",\"4\",\"5\"]'),
(45, 1, '[]', 2, '[\"A\"]', '以下关于进程的描述中，正确的是（  ）', '', '', '[\"进程是通过调度得到CPU的\",\"优先级是进程调度的重要依据，一旦确定就不能改变\",\"在单CPU的系统中，任意时刻都至少有一个进程处于就绪状态\",\"进程申请CPU得不到满足时，其状态为阻塞\"]'),
(46, 1, '[]', 2, '[\"A\"]', '一个进程被唤醒意味着（  ）', '', '', '[\"该进程需要重新竞争CPU\",\"优先级变大\",\"PC B移动到就绪队列之首\",\"进程变为执行状态\"]'),
(47, 1, '[]', 2, '[\"B\"]', '下列情况中必然会引起进程切换的是（  ）', '', '', '[\"一个进程创建后，进入就绪状态\",\"一个进程从执行状态变为就绪状态\",\"一个进程从阻塞状态变为就绪状态\",\"以上都不对\"]'),
(48, 1, '[]', 2, '[\"A\"]', '进程自身决定（  ）', '', '', '[\"从执行状态变为阻塞状态\",\"从执行状态到就绪状态\",\"从就绪状态到执行状态\",\"从阻塞状态到就绪状态\"]'),
(49, 1, '[]', 2, '[\"A\"]', '一次I/O操作的结束，有可能导致（  ）', '', '', '[\"一个进程由阻塞状态变为就绪状态\",\"几个进程由阻塞状态变为就绪状态\",\"一个进程由阻塞状态变为运行状态\",\"几个进程由阻塞状态变为运行状态\"]'),
(50, 1, '[]', 2, '[\"C\"]', '以下（  ）不会引起进程创建。', '', '', '[\"用户登录\",\"作业调度\",\"设备分配\",\"进程请求\"]'),
(51, 1, '[]', 2, '[\"B\"]', '以下关于子进程和父进程的叙述中，正确的是（  ）', '', '', '[\"父进程创建子进程，因此父进程运行完之后，子进程才能运行\",\"父进程和子进程可以并发执行\",\"撤销子进程时，应该同时撤销父进程\",\"撤销父进程时，可以不撤销子进程\"]'),
(52, 1, '[]', 2, '[\"D\"]', '并发进程失去封闭性是指（  ）', '', '', '[\"多个相对独立的进程，以各自的速度向前推进\",\"并发进程的执行结果与速度无关\",\"并发进程执行时，在不同的时刻发生的错误\",\"并发进程，共享变量，其执行结果与速度无关\"]'),
(53, 1, '[]', 2, '[\"D\"]', '下列对临界资源的论述中正确的是（  ）', '', '', '[\"临界资源是指进程能够同时使用的那些资源\",\"临界区包含进程中实现同步互斥的那段代码\",\"临界区是指存放临界资源的那段存储器区域\",\"临界区是指进程中访问临界资源的那段代码\"]'),
(54, 1, '[]', 2, '[\"B\"]', '在下列死锁的解决方法中，属于死锁防范策略的是（ \n ）', '', '', '[\"银行家算法\",\"资源有序分配算法\",\"死锁检测算法\",\"资源分配图简化法\"]'),
(55, 1, '[]', 2, '[\"C\"]', '一个进程释放了一台打印机后，有可能改变（  ） 的状态。', '', '', '[\"自身进程\",\"输入输出进程\",\"另一个等待打印机的进程\",\"所有等待打印机的进程\"]'),
(56, 1, '[]', 2, '[\"D\"]', '若系统中有5台绘图仪，有多个进程需要使用2台，规定每个进程一次允许申请一台，则最多允许,（  ）个进程参与竞争，而不会发生死锁。', '', '', '[\"5\",\"2\",\"3\",\"4\"]'),
(57, 1, '[]', 3, '[\"C\"]', '支持程序存放在不连续内存中的存储管理方法有（  ）。\n I. 动态分区分配\nII. 固定分区分配\nIII. 分页式分配\nIV. 段页式分配\nV. 分段式分配。', '', '', '[\"I,II\",\"III,IV\",\"III,IV,V\",\"II,iV,V\"]'),
(58, 1, '[]', 3, '[\"C\"]', '某虚拟存储器系统采用页式内存管理，使用LRU页面替换算法，考虑下面的页面访问地址流（每次访问在一个时间单位内完成）：1 8 1 7 8 2 7 2 1 8 3 8 2 1 3 1 7 。假定内存容量为4个页面，开始时是空的，则缺页次数为（  ）', '', '', '[\"4\",\"5\",\"6\",\"7\"]'),
(59, 1, '[]', 3, '[\"D\"]', '在动态分区式内存管理中，能使用内存空间中空闲区分布较均匀的算法是（  ）', '', '', '[\"最佳适应算法\",\"最坏适应算法\",\"首次适应算法\",\"循环首次适应算法\"]'),
(60, 1, '[]', 3, '[\"A\"]', '在动态分区式内存管理中，每次分配时，把即能满足要求，又是最小的空闲区分配给进程的算法是（  ）', '', '', '[\"最佳适应算法\",\"最坏适应算法\",\"首次适应算法\",\"循环首次适应算法\"]'),
(61, 1, '[]', 3, '[\"B\"]', '下列关于存储器管理功能的论述中，正确的是（  ）', '', '', '[\"即使是在多道程序设计环境下，用户也能设计用内存物理地址直接访问内存的程序。\",\"内存分配最基本的任务是为了每道程序分配内存，其追求的主要目标是提高存储空间的利用率。\",\"为了提高内存保护的灵活性，内存保护通常由软件实现。\",\"虚拟存储器是在物理上扩充内存容量。\"]'),
(62, 1, '[]', 3, '[\"B\"]', '在下列关于存储器功能的论述中，正确的是（  ）', '', '', '[\"即使在多道程序环境下，用户也可以编制用物理地址直接访问内存的程序\",\"内存分配的基本任务是为每道程序分配内存空间，其追求的目的则是提高内存利用率\",\"为提高内存保护的灵活性，内存保护通常由软件完成\",\"在编译过程中，将程序中的逻辑地址转换为内存空间的物理地址\"]'),
(63, 1, '[]', 3, '[\"C\"]', '在请求调页系统中，若逻辑地址中的页号超过页表控制器寄存器中的页表长度则会引起（  ）', '', '', '[\"输入/输出中断\",\"时钟中断\",\"越界中断\",\"缺页中断\"]'),
(64, 1, '[]', 3, '[\"C\"]', '在段页式分配中，CPU每次从内存中取一次数据，需要访问内存的次数为（  ）', '', '', '[\"1\",\"2\",\"3\",\"4\"]'),
(65, 1, '[]', 3, '[\"B\"]', '在分段式存储管理系统中，为了让两个不同的进程共享同一存储端，下列方法中正确的是（  ）', '', '', '[\"让进程拥有相同的段表\",\"让进程各自的段表项拥有相同的段起始地址和段长度\",\"让进程拥有相同的页表\",\"不同的进程无法实现共享同一存储段\"]'),
(66, 1, '[]', 3, '[\"B\"]', '段页式存储管理，吸取了页式管理和段式管理的长处，其实现原理结合了页式和段式管理的基本思想,即（  ）', '', '', '[\"用分段方法来分配和管理物理存储空间，用分页方法来管理用户地址空间\",\"用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间\",\"用分段方法来分配和管理主存空间，用分页方法来管理辅存空间\",\"用分段方法来分配和管理辅存空间，用分页方法来管理主存空间\"]'),
(67, 1, '[]', 3, '[\"B\"]', '下列技术中，属于以时间换空间的是（  ）', '', '', '[\"分时技术\",\"虚拟技术\",\"并发技术\",\"缓冲技术\"]'),
(68, 1, '[]', 3, '[\"A\"]', '在请求分页系统中，没有优先考虑最近使用过的页面的置换算法是（  ）', '', '', '[\"最佳置换算法\",\"最近最久未使用算法\",\"先进先出算法\",\"时钟置换算法\"]'),
(69, 1, '[]', 3, '[\"C\"]', '现代操作系统中提高内存利用率的功能是（  。 使每道程序能够在不受干扰的环境下运行的功能是（  ）。\nI. 对换\nII. 内存保护\nIII. 地址映射', '', '', '[\"I,II\",\"I,III\",\"III,II\",\"III,III\"]'),
(70, 1, '[]', 3, '[\"D\"]', '静态重定向是在作业的(  )中进行的,动态重定向是在作业的(  )中进行的。\nI. 编译过程\nII. 装入过程\nIII. 修改过程\nIV. 执行过程。', '', '', '[\"I,III\",\"I,IV\",\"II,III\",\"II,IV\"]'),
(71, 1, '[]', 3, '[\"D\"]', '在请求分页系统中的页表中增加的外存始址的作用是( \n )', '', '', '[\"供分配页面时参考\",\"供置换算法参考\",\"供程序访问时参考\",\"供页面调入/调出时参考\"]'),
(72, 1, '[]', 3, '[\"C\"]', '联想寄存器在计算机系统中用于(  )', '', '', '[\"存储文件信息\",\"与主存交换信息\",\"地址变换\",\"存储通道程序\"]'),
(73, 1, '[]', 3, '[\"B\"]', '程序的装入方式中，目标程序可以不经过任何改动，而装入物理内存单元的是(  )', '', '', '[\"静态重定位\",\"动态重定位\",\"编译或汇编\",\"存储扩充\"]'),
(74, 1, '[]', 3, '[\"D\"]', '分页管理中页表的起始地址存放在(  )中。', '', '', '[\"内存\",\"页表\",\"快表\",\"页表寄存器。\"]'),
(75, 1, '[]', 3, '[\"A\"]', '系统抖动现象发生的原因是(  ) ', '', '', '[\"置换算法选择不当\",\"交换信息量过大\",\"内存容量不足\",\"请求页式管理方案\"]'),
(76, 1, '[]', 3, '[\"A\"]', '在页式存储管理系统中，页表内容如下。若页的大小为4KB。则地址转换机构，将逻辑地址零转换成物理地址为（  ）。\n---------------------------\n页号      |   物理块号\n---------------------------\n0           |     2\n---------------------------\n1           |     0\n---------------------------\n2           |     8\n---------------------------\n3           |    11\n---------------------------', '', '', '[\"8192B\",\"1024B\",\"2B\",\"1B\"]'),
(77, 1, '[]', 3, '[\"B\"]', '采用段式存储管理时，一个程序如何分段是在（  ）时候决定的。', '', '', '[\"分配主存\",\"用户编程\",\"装作\",\"程序执行\"]'),
(78, 1, '[]', 3, '[\"A\"]', '在动态分区式内存管理中，首次适应算法的空闲区（ \n ）', '', '', '[\"按地址递增顺序连在一起\",\"始端指针表指向最大空闲区\",\"按大小递增顺序连在一起\",\"寻找从最大空闲区开始\"]'),
(79, 1, '[]', 3, '[\"C\"]', '考虑使用大小相等分区的固定分区方案，分区大小为2^16B，主存的大小为2^24B，使用一个进程表来包含每一个进程对应的分区，那么进程表中指向这些分区的指针需要的位数为(  )', '', '', '[\"24\",\"16\",\"8\",\"40\"]'),
(80, 1, '[]', 3, '[\"A\"]', '下列关于页表的叙述中错误的是(  )', '', '', '[\"在分页系统中，用户程序能访问页表\",\"在页式管理中，页表的作用是实现从虚页号到物理块号的地址映射\",\"段页式管理中，一个页表属于某个段\",\"在二级页表中，外层页表是指向页表的页表\"]'),
(81, 1, '[]', 3, '[\"B\"]', '在一个操作系统中，对内存采用页式存储管理方法所划分的页面大小（  ）', '', '', '[\"要依据内存大小而定\",\"必须相同\",\"要依据CPU的地址结构而定\",\"要依据内存和外存而定\"]'),
(82, 1, '[]', 3, '[\"D\"]', '下列关于请求分页存储管理说法中，不正确的是（  ）', '', '', '[\"程序空间页的大小与计算机物理块的大小总是一致的\",\"页地址变换机构必须由相应的硬件支持\",\"将用户地址空间分为页号和页内偏移，用户是感觉不到的\",\"在请求调页的系统中，用户程序必须全部装入主存\"]'),
(83, 1, '[]', 3, '[\"C\"]', '下列关于页式存储的说法中，正确的是（  ）\nI. 在页式存储管理中，若关闭TLB，则访问每一条数据都要访问两次主存\nII. 页式存储管理器不会产生内部碎片\nIII. 页式存储管理当中的页面是用户可以感知的\nIV. 页式存储方式，采用静态重定位', '', '', '[\"I,II,IV\",\"I,IV\",\"I\",\"I,III\"]'),
(84, 1, '[]', 3, '[\"A\"]', '下面哪种内存管理方法有利于程序的动态链接(  )', '', '', '[\"分段存储管理\",\"分页存储管理\",\"可变式存储管理\",\"固定式存储管理\"]'),
(85, 1, '[]', 3, '[\"C\"]', '设内存的分配情况见。要申请一块40KB的内存空间，若采用最佳适应算法，则所得的分区首址为(  )', '', '', '[\"100KB\",\"190KB\",\"330KB\",\"410KB\"]'),
(86, 1, '[]', 3, '[\"B\"]', '采用段式存储管理的系统中，若地址用24位表示，其中八位表示段号,则允许每段的最大长度是(  )(默认字长为1B)', '', '', '[\"16MB\",\"64KB\",\"256B\",\"4GB\"]'),
(87, 1, '[]', 3, '[\"A\"]', '在采用请求分页式存储管理的系统中，地址变换过程可能会因下列(  )而产生中断。\nI. 地址越界\nII. 缺页\nIII. 访问权限错误\nIV. 存储控制。', '', '', '[\"I,II\",\"II,III\",\"I,II,III\",\"I,III,IV\"]'),
(88, 1, '[]', 3, '[\"B\"]', '某系统的空闲分区表见表如下所示。采用可变式分区管理策略，现有如下作业序列:96KB、20KB、200KB。若用首次适应算法和最佳适应算法来处理这些作业序列，则(  )该作业序列请求。', '', '', '[\"首次适应算法能满足最佳适应算法，不能满足\",\"首先得适应算法，不能满足最佳适应算法能满足\",\"都能满足\",\"都不能满足\"]'),
(89, 1, '[]', 3, '[\"B\"]', '设主存容量为1MB，外存容量为400MB，计算机系统的地址寄存器有24位，那么虚拟的最大容量是（  ）（默认字长为1B）', '', '', '[\"1MB\",\"16MB\",\"17MB\",\"401MB\"]'),
(90, 1, '[]', 3, '[\"D\"]', '在一分页存储管理系统中，页面大小为4096B，现有一逻辑地址为2F6AH，且第0、1、2页一次存储放在物理块5、10、11中，该逻辑地址对应的物理地址为(  )', '', '', '[\"2F6AH\",\"5F6AH\",\"5A6AH\",\"BF6AH\"]'),
(91, 1, '[]', 3, '[\"A\"]', '操作系统采用分页存储管理方式要求什么(  )', '', '', '[\"每一个进程拥有一张页表，且进程的页表驻留在内存中\",\"每个进程拥有一张页表，但只有执行进程的页表驻留在内存中\",\"所有进程共享一张页表，以节约有限的内存空间，但页表必须驻留在内存中\",\"所有进程共享一张页表，只有页表中当前使用的页面必须贮存在内存中。以最大限度的节约有限的内存空间\"]'),
(92, 1, '[]', 3, '[\"D\"]', '以下存储管理方式中会产生内部碎片的是（  ）\nI. 分段虚拟存储管理\nII. 分页虚拟存储管理\nIII. 段页式分页管理\nIV. 固定式分区管理。', '', '', '[\"I,II,III\",\"III,IV\",\"II\",\"II,III,IV\"]'),
(93, 1, '[]', 4, '[\"B\"]', '文件系统采用二级目录结构，这样可以(  )\nI. 缩短访问文件存储器的时间\nII. 实现文件共享\nIII. 节省主存空间\nIV. 解决不同用户之间的文件名冲突', '', '', '[\"IV\",\"I,IV\",\"III,IV\",\"I,II,IV\"]'),
(94, 1, '[]', 4, '[\"A\"]', '通常对文件系统来说，文件名及其属性可以集中在(  )中，以便查找。', '', '', '[\"目录\",\"索引\",\"字典\",\"作业控制块\"]'),
(95, 1, '[]', 4, '[\"C\"]', '文件目录项中不包含的是(  )', '', '', '[\"文件名\",\"文件访问权限说明\",\"文件控制块的物理位置\",\"文件所在的物理位置\"]'),
(96, 1, '[]', 4, '[\"A\"]', '文件系统在创建一个文件时，为它创建一个(  )', '', '', '[\"文件目录项\",\"目录文\",\"逻辑结构\",\"逻辑空间\"]'),
(97, 1, '[]', 4, '[\"D\"]', '在文件系统中，以下不属于文件保护的方法是(  )', '', '', '[\"口令\",\"存储控制\",\"用户权限表\",\"读写之后使用关闭命令\"]'),
(98, 1, '[]', 4, '[\"A\"]', '操作系统为保证未经文件拥有者授权，任何其他用户不能使用该文件，所提供的解决方法是(  )', '', '', '[\"文件保护\",\"文件保密\",\"文件存储\",\"文件共享\"]'),
(99, 1, '[]', 4, '[\"B\"]', '利用Hash法查找文件时，如果目录中相应的目录项是空，则表示(  )', '', '', '[\"文件名已修改\",\"系统中无指定文件名\",\"创建新的文件\",\"修改已存文件名\"]'),
(100, 1, '[]', 4, '[\"C\"]', '下列(  )不是树形目录的优点', '', '', '[\"解决了文件重名问题\",\"提高了文件的检索速度\",\"根目录到任何文件有多条通路\",\"便于进行存储权限控制\"]'),
(101, 1, '[]', 4, '[\"A\"]', '由字符序列组成，文件内信息不再划分结构，这是指( \n )', '', '', '[\"流式文件\",\"记录式文件\",\"顺序文件\",\"有序文件\"]'),
(102, 1, '[]', 4, '[\"C\"]', '磁盘存储器由(  )组成。\nI. 磁盘\nII. 通道\nIII. 驱动器结构\nIV. 控制器\nV. 缓冲区', '', '', '[\"I,II,V\",\"I,II,IV\",\"I,III,IV\",\"I,IV,V\"]'),
(103, 1, '[]', 4, '[\"B\"]', '磁盘的读写单位是(  )', '', '', '[\"块\",\"扇区\",\"簇\",\"字节\"]'),
(104, 1, '[]', 4, '[\"B\"]', '在文件的逻辑系统中，不属于有结构文件的是（  ）', '', '', '[\"索引文件\",\"分区文件\",\"链接文件\",\"索引顺序文件\"]'),
(105, 1, '[]', 4, '[\"C\"]', '如果文件需要随机访问，且文件大小不固定，则以选择（  ）文件结构。', '', '', '[\"连续\",\"链接\",\"索引\",\"以上都不对\"]'),
(106, 1, '[]', 4, '[\"B\"]', '在下列物理文件中，最不适合对文件进行随机访问的是（  ）', '', '', '[\"顺序文件\",\"隐式链接文件\",\"显式链接文件\",\"索引文件\"]'),
(107, 1, '[]', 4, '[\"C\"]', '在某系统中，一个FCB占64B，盘块大小为1KB文件目录中共有3200个FCB，故查找一个文件，平均启动磁盘次数为(  )', '', '', '[\"50\",\"64\",\"100\",\"200\"]'),
(108, 1, '[]', 4, '[\"B\"]', '以下磁盘调度算法中可能出现饥饿现象的是(  )', '', '', '[\"电梯调度\",\"最短寻道时间优先\",\"循环扫描算法\",\"先来先服务\"]'),
(109, 1, '[]', 4, '[\"D\"]', '设磁盘的I/O操作请求队列中的柱面号为55、58、39、18、90、160、150、38、184。磁头的初始位置为100，采用SSTF（最短寻道时间优先算法），则磁头需移动的磁道数为（  ）', '', '', '[\"55\",\"184\",\"200\",\"248\"]'),
(110, 1, '[]', 4, '[\"C\"]', '设磁盘I/O请求队列中柱面号为19，376，205，134,18,56，193，396，29,3,19，40,磁头的起始位置为100，若采用SCAN(电梯调度）算法（磁头的当前是往柱面号小的方向移动)，则磁头移动共需要移动的磁道数为(  )。(该调度算法的磁头移动到镇最内或外侧会改变方向）', '', '', '[\"205\",\"480\",\"490\",\"512\"]'),
(111, 1, '[]', 4, '[\"C\"]', '若用8个字(字长为32位)组成的位示图管理内存，假定用户归还一个块号为100的内存块时，它对应的位置图的位置为(  )(统一由0开始编号)', '', '', '[\"字号为3，位号为5\",\"字号为4，位号为4\",\"字号为3，位号为4\",\"字号为4，位号为5\"]'),
(112, 1, '[]', 5, '[\"C\"]', '在I/O设备控制方式的发展过程中，最主要的推动力是(  )', '', '', '[\"提高资源利用率\",\"提高系统吞吐量\",\"减少CPU对I/O控制的干扰\",\"缓解CPU速度与I/O速度不匹配的矛盾\"]'),
(113, 1, '[]', 5, '[\"C\"]', 'CPU输出数据的速度远远高于打印机的打印速度，为解决这一矛盾可采用(  )', '', '', '[\"并行技术\",\"通道技术\",\"缓冲技术\",\"虚存技术\"]'),
(114, 1, '[]', 5, '[\"D\"]', '设备的打开关闭读写等操作是由(  )完成的', '', '', '[\"用户程序\",\"编译程序\",\"设备分配程序\",\"设备驱动程序\"]'),
(115, 1, '[]', 5, '[\"A\"]', 'DMA控制方式是在(  )之间建立一条直接数据通路。', '', '', '[\"I/O设备和主存\",\"两个I/O设备\",\"I/O设备和CPU\",\"CPU和主存\"]'),
(116, 1, '[]', 5, '[\"C\"]', '在一般大型计算机系统中，主机对外部设备的控制可以通过通道控制器和设备三个层次来实现，以下叙述中正确的是(  )', '', '', '[\"设备控制器和通道可以分别控制设备\",\"设备控制器，通道和设备可以并行工作\",\"通道控制设备控制器，设备控制器，控制设备工作\",\"以上都不对\"]'),
(117, 1, '[]', 5, '[\"A\"]', '大多数低速设备都属于（  ）设备。', '', '', '[\"独享\",\"共享\",\"虚拟\",\"SPOOLing\"]'),
(118, 1, '[]', 5, '[\"B\"]', '在操作系统中，用户使用I/O时，通常采用的是(  )', '', '', '[\"物理设备名\",\"逻辑设备名\",\"虚拟设备名\",\"设备牌号\"]'),
(119, 1, '[]', 5, '[\"C\"]', '下列算法中，设备分配常用的一种算法是(  )', '', '', '[\"短作业优先\",\"最佳适应\",\"先来先服务\",\"首次适应\"]'),
(120, 1, '[]', 5, '[\"A\"]', '将系统中的每一台设备按某种原则进行统一编号，这些编号作为区分硬件和识别设备的代号，该编号称为设备的(  )', '', '', '[\"绝对号\",\"相对号\",\"类型号\",\"符号名\"]'),
(121, 1, '[]', 5, '[\"D\"]', 'SPOOLing技术主要的目的是(  )', '', '', '[\"提高CPU和设备交换信息的速度\",\"提高主辅存接口\",\"减轻用户的编程负担\",\"提高独占设备的利用率\"]'),
(122, 1, '[]', 5, '[\"C\"]', '下列存储介质中即可随机访问又和顺序访问的是（ \n ）。\nI. 光盘\nII. SD卡\nIII. U盘\nIV. 磁盘。', '', '', '[\"II,III,IV\",\"I,III,IV\",\"I,II,III,IV\",\"IV\"]'),
(123, 1, '[]', 5, '[\"C\"]', '大多数设备控制器是由三部分组成的，其中用于实现对设备的控制的是（  ）', '', '', '[\"设备控制器与处理器的接口\",\"设备控制器与设备的接口\",\"I/O逻辑\",\"以上都不对\"]'),
(124, 1, '[]', 5, '[\"D\"]', '在设备管理中，设备映射表(DMT)的作用是(  )', '', '', '[\"管理物理设\",\"管理逻辑设备\",\"实现输入/输出\",\"建立逻辑设备与物理设备的对应关系\"]'),
(125, 1, '[]', 5, '[\"D\"]', 'SPOOLing系统的输入井和输出井表示（  ）', '', '', '[\"磁盘上的两个存储器\",\"内存中的两个缓冲区\",\"输入设备和输出设备\",\"存放用户的输入数据和输出数据的外存空间\"]'),
(126, 1, '[]', 5, '[\"A\"]', '缓存技术的缓冲池在（  ）中。', '', '', '[\"内存\",\"外存\",\"ROM\",\"寄存器\"]');

-- --------------------------------------------------------

--
-- 表的结构 `tag`
--

CREATE TABLE `tag` (
  `id` int(11) NOT NULL,
  `label` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `value` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `tag`
--

INSERT INTO `tag` (`id`, `label`, `value`) VALUES
(4, '死锁', 'Deadlock'),
(5, '线程', 'thread'),
(6, '状态', 'state');

-- --------------------------------------------------------

--
-- 表的结构 `type`
--

CREATE TABLE `type` (
  `id` int(11) NOT NULL,
  `label` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `value` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `type`
--

INSERT INTO `type` (`id`, `label`, `value`) VALUES
(1, '单选', 'radio'),
(2, '多选', 'checkbox');

-- --------------------------------------------------------

--
-- 表的结构 `user`
--

CREATE TABLE `user` (
  `id` int(11) NOT NULL,
  `username` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `password` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `appkey` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- 转存表中的数据 `user`
--

INSERT INTO `user` (`id`, `username`, `password`, `appkey`) VALUES
(1, 'admin', '21232f297a57a5a743894a0e4a801fc3', '4251a24d19641f3cccebd161094a5941'),
(2, 'emlia', '18bf000c6b771e9e8e5641226399db7c', 'dff473d1c14e1efddeb0d46e31f67a04'),
(3, 'emlia11', 'cce8e45b90ac05366ff9fba340ea830b', 'c661526d06c997ae30642c4128687609'),
(4, 'emlia111', 'fa7a42779e8be95e2c8b23e2043c9423', '69e26184332b3407e3f0b1def3811a86');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `answer`
--
ALTER TABLE `answer`
  ADD PRIMARY KEY (`userid`);

--
-- Indexes for table `chapter`
--
ALTER TABLE `chapter`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `configuration`
--
ALTER TABLE `configuration`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `question`
--
ALTER TABLE `question`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `tag`
--
ALTER TABLE `tag`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `type`
--
ALTER TABLE `type`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `user`
--
ALTER TABLE `user`
  ADD PRIMARY KEY (`id`);

--
-- 在导出的表使用AUTO_INCREMENT
--

--
-- 使用表AUTO_INCREMENT `chapter`
--
ALTER TABLE `chapter`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=6;

--
-- 使用表AUTO_INCREMENT `configuration`
--
ALTER TABLE `configuration`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=1000;

--
-- 使用表AUTO_INCREMENT `question`
--
ALTER TABLE `question`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=127;

--
-- 使用表AUTO_INCREMENT `tag`
--
ALTER TABLE `tag`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=7;

--
-- 使用表AUTO_INCREMENT `type`
--
ALTER TABLE `type`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=3;

--
-- 使用表AUTO_INCREMENT `user`
--
ALTER TABLE `user`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=5;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;